%!TEX root = draft.tex
%\newcommand{\seqPQ}{\mathsf{SeqPQ}}

\section{CRDT Implementations}
\label{sec:CRDT implementations}

A distributed system contains multiple objects, and each objects is replicated on each replica. Each object has a type, which contains its method and data type. A client of a replica interact with the objects by calling the method and then obtaining the return value. Here we do not bound the number of replica identifiers and objects.

Let $\mathbb{OBJ}$ be the set of objects and $\mathbb{R}$ be the set of replica identifiers. We consider a finite set $\mathbb{M}$ of method names; and a possibly infinite set $\mathbb{D}$ of arguments and return values, the data domain. Each data type $t = (M,D)$ has a set $M \subseteq \mathbb{M}$ of methods and a data domain $D \subseteq \mathbb{D}$. Finally we have a infinite set $\mathbb{OID}$ of operation identifiers, corresponding to each individual operation performed on the CRDT throughout an execution.

Without loss of generality we will consider that the methods in $\mathbb{M}$ can be separated in two disjoint sets of methods: $\mathbb{Q}$ query methods that has no influence on the ``abstract state'' and normally returns an observation of the ``abstract state'' , and $\mathbb{U}$ update methods that has influence on the ``abstract state''. Note that some update operation can also need to read the ``abstract state''. For example, a $add(a,b)$ operation is an operation of distributed list which intends to put item $a$ immediately after item $b$. This operation implicitly requires that item $b$ is already in list.

$\mathit{Optimistic \ replication \ algorithms}$ is a type of distributed algorithms where each client contains a copy of data structure; a client operations takes effect instantly at its replica without any synchronization, and then broadcast to other replicas and got applied. Convergent or Commutative Replicated Data Types (CRDTs) is a typical kinds of optimistic replication algorithms. In this section, we will introduce CRDT algorithms and their formation.

In practice, there are two kinds of CRDT implementations: state-based CRDT and operation-based CRDT. In state-based CRDT, an update operation will send the modified local state into other replicas. The state-based PN-counter is an example of state-based CRDT algorithms and is shown below. Keyword $\mathit{payload}$ indicate the local state, and keyword $\mathit{initial}$ specifies the initial value of local state. Function $\mathit{myID}()$ returns the current replica identifier, and $\mathit{reps}()$ returns the number of replicas of the distributed system. Vector $P$ (resp., $N$) is a vector such that $P[i]$ (resp., $N[i]$) is the number of increase that is generated by replica $i$ and is observed by current replica. This algorithm assumes that the set of replica is already known and is fixed.

Method $\mathit{inc}$ increase the counter by $1$, method $\mathit{dec}$ decrease the counter by $1$, and method $\mathit{read}$ returns the current counter value. Assume the replica identifier of current replica is $r$. When the current replica does $\mathit{inc}$, it modify $P[r]$ into $P[r]+1$. When the current replica does $\mathit{dec}$, it modify $N[r]$ into $N[r]+1$. When the current replica does $\mathit{read}$, it returns $\Sigma_{i}^{n} P[i] - \Sigma_{i}^{n} N[i]$. When the current replica receive a message of modified payload $Z$, it uses function $\mathit{merge}()$ to update the current local state. $\mathit{merge}$ takes the maximum of each replica in the vector.

\renewcommand{\algorithmcfname}{CRDT Implementation}
\noindent
%\begin{minipage}{.5\textwidth}
\noindent\begin{algorithm}[H]
$\mathit{payload}$ integer[$\mathit{reps}$()] P, integer[$\mathit{reps}$()] N; \\
$\mathit{initial}$ [0,\ldots,0],[0,\ldots,0]; \\

$\mathit{inc}()$ \\
%\ \ \ \ let \ g = myID();\\
\ \ \ \ P[$\mathit{myID}$()] = P[$\mathit{myID}$()] + 1; \\

$\mathit{dec}()$ \\
%\ \ \ \ let \ g = myID();\\
\ \ \ \ N[$\mathit{myID}$()] = N[$\mathit{myID}$()] + 1; \\

$\mathit{read}()$ \\
\ \ \ \ \KwRet $\Sigma_{i}^{n} P[i] - \Sigma_{i}^{n} N[i]$; \\

$\mathit{merge}(Z)$ \\
\ \ \ \ $\forall i$, $P[i] = \mathit{max}(P[i],Z.P[i])$; \\
\ \ \ \ $\forall i$, $N[i] = \mathit{max}(N[i],Z.N[i])$; \\
\caption{State-based PN-counter}
\label{Method1}
\end{algorithm}

In operation-based CRDT, an update operation will send a description of this operation into other replica. Here we take a more complex algorithm, replicated growable array (RGA), as an example of operation-based CRDT and it is shown below.

\renewcommand{\algorithmcfname}{CRDT Implementation}
\noindent
%\begin{minipage}{.5\textwidth}
\noindent\begin{algorithm}[H]
$\mathit{payload}$ TI-tree N, set T; \\
$\mathit{initial}$ $\emptyset$,$\emptyset$; \\

$add(a,b)$ \\
\ \ $\mathit{atSource}$: \\
\ \ \ \ $\mathit{pre}$: \ $b = \circ \vee ( b \neq \circ \wedge (b,\_,\_) \in N \wedge b \notin T)$ \\

%\ \ \ \ \If {$N = \emptyset$}
%    { \ \ \ \ let \ $ts_a$ = (myID(),1); \\ }
%\ \ \ \ \Else
%    {\ \ \ \ let \ $ts_a$ = (myID(),$\mathit{max}\{ c' \vert (\_,(\_,c'),\_) \in N \} +1$); \\ }

%\ \ \ \ \If {$b = \circ$}
%    { \ \ \ \ let \ $ts_b$ = (0,0); \\ }
%\ \ \ \ \Else
%    { \ \ \ \ let \ $ts_b$ be time-stamp of $b$ in $N$; \\ }

\ \ \ \ let \ $ts_a$ = ($N = \emptyset$) ? (1,$\mathit{myID}$()) ! ($\mathit{max}\{ c' \vert (\_,(\_,c'),\_) \in N \} +1$,$\mathit{myID}$()); \\
\ \ \ \ let \ $ts_b$ = ($b = \circ$) ? (0,$r_0$) ! (the time-stamp of $b$ in $N$); \\

\ \ $\mathit{downstream}(a,ts_a,ts_b)$: \\
\ \ \ \ $\mathit{pre}$: \ $b = \circ \vee ( b \neq \circ \wedge (b,ts_b,\_) \in N)$ \\

\ \ \ \ $N = N \cup \{ (a,ts_a,ts_b) \}$.


$rem(a)$ \\
\ \ $\mathit{atSource}$: \\
\ \ \ \ $\mathit{pre}$: \ $a \neq \circ \wedge (a,\_,\_) \in N \wedge a \notin T$ \\

\ \ $\mathit{downstream}(a)$: $\mathit{pre}$ \ $a \neq \circ \wedge (a,\_,\_) \in N)$

\ \ \ \ $T = T \cup \{ a \}$.

$read()$ \\
\ \ \ \ \KwRet $\mathit{trans}(N,T)$; \\

\caption{RGA}
\label{Method1}
\end{algorithm}

Each update operation of operation-based CRDT ie executed with two phases: Its first phase, marked $\mathit{atSource}$, is local to the current replica. It is enabled if its (optional) pre-condition, marked $\mathit{pre}$, is true currently in local state. It generates the information to be delivered, which is the argument of $\mathit{downstream}$. Its second phase, marked $\mathit{downstream}$, executed immediate after the current replica, and asynchronously at other replica when they receive the message of this operation. It is enabled if its (optional) pre-condition is true.

In RGA algorithm, a replica store the list as a timestamp insertion tree (TI-tree) $N$, and stores the deleted items in tombstone $T$. A TI-tree $N$ is a set of tuples $(a,t,p)$, where $a$ is a item, $t$ is its unique time-stamp, and $p$ is the time-stamp of its ``parent'' node. Each time-stamp is a tuple $(c,r)$ with $c \in \mathbb{N}$ and $r \in \mathbb{R}$. A order $<_{\mathit{ts}}$ between time-stamps is defined, such that $(c_1,r_1) <_{\mathit{ts}} (c_2,r_2)$, if $c_1 < c_2 \vee (c_1 = c_2 \wedge r_1 <_r r_2)$, where $<_r$ is a total-order over $\mathbb{R}$. There is a pre-existed item $\circ$ of TI-tree with time stamp $(0,r_0)$, which are considered as the root of the tree. Each element of $N$ should have unique item and time stamp, and the elements of $N$ are required to form a tree by following the parent field. The tombstone $T$ is a set of items and records items been removed from the list.

Method $\mathit{add}(a,b)$ intends to add item $a$ into the list immediately after a existing item $b$. Method $\mathit{rem}(a)$ removes $a$ from the list. Method $\mathit{read}$ returns the current list content. When the current replica does $\mathit{add}(a,b)$, it generate a tuple $(a,ts_a,ts_b)$ and put it into $N$. Here $ts_b$ is the time-stamp of $b$, and $ts_a$ is a new time-stamp that is larger than any time stamp in $N$. When the current replica does $\mathit{rem}(a)$, it put $a$ into tombstone. When the current replica does $\mathit{read}$, it uses function $\mathit{trans}(N,T)$ to return the list seen by the current replica, which is a sequences obtained by traversing $N$ in prefix order (children are visited in decreasing time-stamp order) and keeping only items that are not in $T$.


Multi-value register is also a common-used data structures and its sequential specification (seen in the next section) is much different from that of the previous two examples. A state-based multi-value register algorithm is shown below.


\renewcommand{\algorithmcfname}{CRDT Implementation}
\noindent
%\begin{minipage}{.5\textwidth}
\noindent\begin{algorithm}[H]
$\mathit{payload}$ $S \subseteq D \times \mathbb{N}^{\mathit{reps}()}$; \\
$\mathit{initial}$ $\emptyset$; \\

$\mathit{write}(a)$ \\
\ \ \ \ let \ g = $\mathit{myID}$(); \\
\ \ \ \ let $\mathcal{V} = \{ V \vert \exists x, (x,V) \in S \}$; \\
\ \ \ \ let $V' = [ \mathit{max}_{V \in \mathcal{V}} V[j] ]_{j \neq g}$; \\
\ \ \ \ let $V'[g] = (\mathit{max}_{V \in \mathcal{V}} V[g]) + 1$; \\
\ \ \ \ $S = (a,V')$; \\

$\mathit{read}()$ \\
\ \ \ \ \KwRet $S' = \{ a \vert (a,\_) \in S \}$; \\

$\mathit{merge}(Z)$ \\
\ \ \ \ let $A' = \{ (x,V) \in S \vert \forall (x',V') \in Z.S, \exists i, V[i] \geq V'[i] \}$; \\
\ \ \ \ let $B' = \{ (x,V) \in Z.S \vert \forall (x',V') \in S, \exists i, V[i] \geq V'[i] \}$; \\
\ \ \ \ $S = A' \cup B'$; \\
\caption{state-based multi-value register}
\label{Method1}
\end{algorithm}

Each replica stores a set $S$ of items such that each item can not dominate other items. To do conflict resolution, we associate each item $a$ in $S$ with a version vector $V$. We say version vector $V$ dominates version vector $V'$, if $\forall i$, $V[i] > V'[i]$.

Method $\mathit{write}(a)$ intends to write $a$ into register. Method $\mathit{read}$ returns the current register content. When the current replica does $\mathit{write}(a)$, it generates a new version vector that dominates all previous ones in $S$. When the current replica does $\mathit{read}$, it returns the set of items in $S$. When the current replica receive a message of modified payload $Z$, we takes the union of every items in $S$ and $Z.S$ whose version vector is not dominated by that of an item in the other set. This algorithm assumes that the set of replica is already known and is fixed.


To enable formally verification of CRDT algorithms, it is necessary to give formal definition of CRDT-algorithms. Let $\mathbb{MSG}$ be the set of message contents, such as $inc$ of state-based PN-counter, or $(a,ts_a,ts_b)$ of RGA. Then, CRDT implementations are defined as follows, where operations and receiving messages are defined as functions.

\begin{definition}[CRDT implementations]
\label{definition:CRDT implementations}
A CRDT implementation for a type $t = (M,D)$ is a tuple $I_t(r) = (\Sigma, \Sigma_0, \mathit{Msg}, \mathit{do},\mathit{receive})$. Here $r \in \mathbb{R}$, $\Sigma_0 \subseteq \Sigma$, $\mathit{Msg} \subseteq \mathbb{MSG}$, $\mathit{do}:\Sigma \times M \times D \rightarrow \Sigma \times D \times (\mathit{Msg} \cup \{ \emptyset \} )$, and $\mathit{receive}: \Sigma \times \mathit{Msg} \rightarrow \Sigma$.
\end{definition}

Here $\Sigma$ is the set of local states and $\Sigma_0$ is the set of initial state. For example, in state-based PN-counter, since there are many possibility of total number of replicas, $\Sigma_0$ is a set of more than one elements. $r$ is the replica identifier of current replica. The reason of containing $r$ in the definition of CRDT implementations is that, some algorithms need the current replica identifier to generate time-stamp. When the current local state is $\sigma$ and the client intends to perform a operation of method $m$ with argument $a$, a $\mathit{do}$ action is launched, which update the local states, returns a value, and possibly generate messages. A $\mathit{do}$ action of update method will generate messages, while a $\mathit{do}$ action of query method will not generate message. When this replica receives a message of other replica, a $\mathit{receive}$ action will be launched, which updates the current local states according to the message. If a operation has no arguments or return value, or does not generate message, then we can safely omit the corresponding tuples in $\mathit{do}$ actions.

The following is an example of formal definition of state-based PN-counter. The formal definition of more CRDT implementations are given in Appendix \ref{sec:appendix definitions of section CRDT implementations}. Here we denote by $f[i:j]$ the function that has the same value as $f$ everywhere, except for $i$, where it has the value $j$. Since each operation is executed without synchronization, it is not hard to obtain formal definition from informal algorithms.

\begin{example}[state-based PN-counter]
\label{definition:state-based PN-counter}
$I_t(r) = (\Sigma, \sigma_0, \mathit{Msg}, \mathit{do},\mathit{receive})$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\Sigma = \{ (P,N) \vert$, $P$ and $N$ are vector of integers with same length $\}$. $\Sigma_0 = \{ (P_0,N_0) \vert (P_0,N_0) \in \Sigma$, $P_0$ and $N_0$ maps each index into $0 \}$.

\item[-] $\mathit{Msg} = \Sigma$.

\item[-] $\mathit{do}((P,N),\mathit{inc}) = (P[r:P[r]+1],N),(P[r:P[r]+1],N))$,

\item[-] $\mathit{do}((P,N),\mathit{dec}) = (P,N[r:N[r]+1]),(P,N[r:N[r]+1])$,

\item[-] $\mathit{receive}((P,N),(P',N')) = (\lambda s. \mathit{max}\{  P[s], N'[s] \}, \mathit{max}\{  N[s], N'[s] \},)$,
\end{itemize}
\end{example}





















\section{Distributed Linearizability}
\label{sec:distributed-lin}

In this section, we propose a framework to specify the expected outcome in a linearizable approach, without referring to implementation details.



\subsection{Histories}
\label{subsec:histories}

We define our specification on histories, which are abstract version of detailed executions and does not contain implementation details such as message delivery. Histories are used to capture the notion of client-observable effects (operations), as well as their order in each replica, and their visibility relation.

Let us introduce the notion of operations. A operation label $m(a) \Rightarrow b$ with $m \in \mathbb{M}$ and $a,b \in \mathbb{D}$ is the user-observable behavior of an operation, which indicates that this operation calls method $m$ with argument $a$ and its return value is $b$. An operation is defined to be a tuple $(\ell,i,x)$, where $\ell$ is a operation label, $i \in \mathbb{OID}$ is a unique operation identifier, and $x \in \mathbb{OBJ}$ is the objects of this operation. Let $\mathbb{OP}$ be the set of operations. For operation label $m(a) \Rightarrow b$, when the argument (resp., return value) is not used, we write $m()\Rightarrow b$ (resp., $m(a)$) instead for short.

With the notion of operations, we can now define histories.

\begin{definition}[histories]
\label{definition:histories}
A history is a tuple of the form $(\mathit{Op},\mathit{ro},\mathit{vis})$ .Here $\mathit{Op} \subseteq \mathbb{OP}$ is a set of operations; $\mathit{ro} \subseteq \mathit{Op} \times \mathit{Op}$ is the replica order, which is a union of transitive, irreflexive and total orders over $\mathit{Op}$; $\mathit{vis} \subseteq \mathit{Op} \times \mathit{Op}$ is the visibility order, which is acyclic and relates operations of same object. We require that $\mathit{ro} \subseteq \mathit{vis}$.
\end{definition}

$(o_1,o_2) \in \mathit{ro}$ represents that $o_1$ and $o_2$ are of same replica and the time point of $o_1$ is before that of $o_2$. $(o_1,o_2) \in \mathit{vis}$ means that $o_2$ is aware of $o_1$. In detailed execution, this means that some message carrying the effect of $o_1$ has already been delivered into replica of $o_2$. In state-based CRDT implementation, this message contains some state aware of $o_1$, while in operation-based CRDT implementation, this message is the message of $o_1$. Based on this intuition, when $(o_1,o_2) \in \mathit{vis}$ and $o_1$ and $o_2$ are of same replica, we assume that $o_1 \in \mathbb{U}$, since otherwise $o_1 \in \mathbb{Q}$ and has no side-effect.













%%% Local Variables:
%%% mode: latex
%%% TeX-master: "draft"
%%% End:
