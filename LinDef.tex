%!TEX root = draft.tex
%\newcommand{\seqPQ}{\mathsf{SeqPQ}}


\section{Definition of Linearizability}
\label{sec:definition of linearizability} 

Let us start our formation of executions, specifications and linearizations of CRDT.  

We consider a finite set $\mathbb{M}$ of method names; and a possibly infinite set $\mathbb{D}$ of arguments and return values, the data domain. Without loss of generality we will consider that the methods in $\mathbb{M}$ can be separated in two disjoint sets of $\mathbb{Q}$ query methods, and $\mathbb{U}$ update methods. We consider replicated data types which are distributed across a set of replicas; the set of replica identifiers is denoted by $\mathbb{R}$. We assume that each replica contains a copy of the data type state. Finally we have a infinite set $\mathbb{O}$ of operation identifiers, corresponding to each individual operation performed on the CRDT throughout an execution.

Operation labels \mbox{$m(a)\Rightarrow b$} with $m \in \mathbb{M}$ and $a,b \in \mathbb{D}$, indicate that the operation is a call to method $m$ with argument $a$ and the result of the operation is the value $b$. When $m$ does not use the argument (resp., return value), we write $m()\Rightarrow b$ (resp., $m(a)$) instead. We define an operation $o$ to be a tuple $(\ell,i)$, where $\ell$ is an operation label and $i \in \mathbb{O}$ is a unique operation identifier. 

\noindent {\bf Sequential Specification:} A sequential specification is used to state the sequential intuition of operations. Let specification alphabet $\mathbb{A}$ be a set of a tuples $(o,s)$, where $o$ is an operation and $s$ is a set of operation identifiers. The reason of introducing such set of operation identifiers is that, in sequential specifications some operations should only influence a subset of previous operations. Such operation identifier set is just the operations influenced by this operation. With specification alphabet, a sequential specification of CRDT is given as a set of sequences over specification alphabets as follows. From now on, we implicitly assume that in a sequence of specification alphabets, each item has a unique operation identifier. 

\begin{definition}[Sequential Specification]
\label{definition:sequential specification} 
A sequential specification $\mathit{spec}_s \subseteq \mathbb{A}^*$ is a set of strings over specification alphabet $\mathbb{A}$. 
\end{definition} 

\noindent {\bf Distributed Specification:} Each element of distributed specification is a tuple $(s,v)$, where $s \subseteq \mathbb{A}^*$ is a sequence of specification alphabet, and $v$ is a function that maps each item $a$ of $s$ into a subset of items before $a$ in $s$. Here $s$ essentially is the linearization of an execution, while $v$ is used to ensure each specification alphabet is correct in this sequence. %Given a sequence $s \subseteq \mathbb{A}^*$ of specification alphabets and a specification alphabets $a$, let $\mathit{itm}(s)$ be the set of specification alphabets of $s$, and $\mathit{itmBef}(s,a)$ be the set of specification alphabets of $s$ that appears before $a$, or $\emptyset$ otherwise. 
Given a sequence $s$ and a set of operations $S$, let $s \uparrow_{S}$ be the projection of $s$ over $S$. Given a sequence $s$ and an item $a$ of $s$, let $\mathit{bef}(s,a)$ contains the set of items of $s$ that appear before $a$ in $s$, as well as all the subsets of this set. 

\begin{definition}[Distributed Specification]
\label{definition:distributed specification}
A distributed specification $\mathit{spec}_d$ w.r.t a sequential specification $\mathit{spec}_s$ is a set of tuples $(s,v)$, where $s \subseteq \mathbb{A}^*$, and %$v: \mathit{itm}(s) \rightarrow 2^{\mathit{items}(s)}$ is a function that maps each item $a$ into $\mathit{itmBef}(s,a)$.
%$v$ is a function that maps each specification alphabet $a$ of $s$ into a subset of specification alphabet of $s$ that appears before $a$ in $s$. 
$v$ is a function that maps each specification alphabet $a$ of $s$ into $\{ a \} \cup x$ with $ x \in \mathit{bef}(s,a)$. Moreover, the following condition need to be satisfied:

\begin{enumerate}[(i)]
\item For each specification alphabet $a$ of $s$, $s \uparrow_{v(a)} \in \mathit{spec}_s$. 
\end{enumerate} 
\end{definition}





