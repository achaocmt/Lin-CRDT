%!TEX root = draft.tex
%\newcommand{\seqPQ}{\mathsf{SeqPQ}}

\section{CRDT Implementations and Its Semantics}
\label{sec:CRDT implementations and its semantics}

A replicated store is a set of objects. An object has a type and is replicated on each replica. Here we do not bound the number of replica identifiers and objects. A client works on one replica and interacts with the store by calling the method and then obtaining the return value.

A replicated data type implementation shows how a algorithm works at one replica, including how to perform an operation and send message, as well as when receiving message, how to update the local data. Let $\mathbb{MSG}$ be the set of message contents.

\begin{definition}[Replicated Type Implementation]
\label{definition:replicated type implementation}
A replicated type implementation for a type $t = (M,D)$ is a tuple $I_t(r) = (\Sigma, \sigma_0, M, \mathit{do},\mathit{receive})$. Here $r \in \mathbb{R}$, $\sigma_0 \in \Sigma$, $\mathit{do}:\Sigma \times \mathbb{M} \times D \rightarrow \Sigma \times D \times (\mathbb{MSG} \cup \{ \emptyset \} )$, and $\mathit{receive}: \Sigma \times \mathbb{MSG} \rightarrow \Sigma$.
\end{definition}

Here $\Sigma$ is a set of states of object of one replica. $\sigma_0$ is the initial state. When the current local state is $\sigma$ and the client intends to perform a operation of method $m$ with argument $a$, a $\mathit{do}(\sigma,m,a)$ action is launched, which update the local states, returns a value, and possibly generate messages. If $m \in \mathbb{U}$, a $\mathit{do}$ action of method $m$ will generate message; else, if $m \in \mathbb{Q}$, a $\mathit{do}$ action of method $m$ will not generate message. When this replica receives a message from other replica, a $\mathit{receive}$ action will be launched, which updates the current local states according to the message. If a operation has no arguments or return value, or does not generate message, then we can safely skip the corresponding ones in $\mathit{do}$ actions of $I_t$. $r$ is the replica identifier of current replica, since some algorithms need the current replica identifier to generate time-stamp.

In practice, there are two kinds of CRDT implementations: operation-based CRDT and state-based CRDT. In operation-based CRDT, each message carries a description of the latest operation of the sending replica. In state-based CRDT, each message carries a description of the local state of the sending replica.

In the following we give the example of two algorithms: operation-based counter, and replicated growable array (RGA), which is also operation-based. More algorithms are given in Appendix \ref{sec:appendix definitions of section CRDT implementations and its semantics}.

\begin{example}[operation-based counter]
\label{definition:operation-based counter}
$I_t(r) = (\Sigma, \sigma_0, M, \mathit{do},\mathit{receive})$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\Sigma = \mathbb{N}$, $\sigma_0 = 0$, each message is chosen from $\{ \mathit{inc}, \mathit{dec} \}$,

\item[-] $\mathit{do}(i,\mathit{inc}) = (i+1,\mathit{inc})$,

\item[-] $\mathit{do}(i,\mathit{dec}) = (i-1,\mathit{dec})$,

\item[-] $\mathit{do}(i,\mathit{read}) = (i,i)$,

\item[-] $\mathit{receive}(i,\mathit{inc}) = (i+1)$, $\mathit{receive}(i,\mathit{dec}) = (i-1)$.
\end{itemize}
\end{example}


\begin{example}[RGA]
\label{definition:rga implementation}
In RGA algorithm, a replica store the list as a tree, where the list is obtained by traversing the tree in prefix order, and each node of the tree stores a item of list, a pointer to parent node of the tree, and a time-stamp for possible conflict resolution. The already-deleted items of the tree are stored in tombstone. Here we assume that each item of the list is globally unique.

Formally, each replica stores a (1) `set $N$ of tuples $(a,t,p)$, where $a \in D$ is a item, $t$ is its unique time-stamp, and $p$ is the time-stamp of its ``parent'', and (2) a set $T$ of tombstones, which are set of items removed from the list. Each time-stamp is a tuple $(x,r)$ with $x \in \mathbb{N}$ and $r \in \mathbb{R}$. We define a order $<_{\mathit{ts}}$ between time-stamps, such that $(x_1,r_1) <_{\mathit{ts}} (x_2,r_2)$, if $x_1 < x_2 \vee (x_1 = x_2 \wedge r_1 <_r r_2)$, where $<_r$ is a total-order over $\mathbb{R}$. The elements of $N$ are required to form a tree by following the parent field (a special time-stamp value $\circ$ represents the root). Let $\mathit{list}(N,T)$ be the list seen by the local replica, which is a sequences obtained by traversing $N$ in prefix order (children are visited in decreasing time-stamp order) and keeping only items that are not in $T$. In the interface of RGA, we assume that the first item of list is fixed to be $\circ$.

To insert a new item $a$ into list after a existing item $b$ of $N$, we put $(a,t,p_b)$ into $N$, where $p_b$ is the time-stamp of $b$, and t is a time-stamp that is bigger than all time-stamp of $N$. We remove an item $a$ of $N$ by putting $a$ into $T$. To read the list, we return $\mathit{list}(N,T)$. The tuples of RGA is defined as follows: $I_t(r) = (\Sigma, \sigma_0, M, \mathit{do},\mathit{receive})$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each item of $\Sigma$ is a tuple $(N,T)$ as above, $\sigma_0 = (\emptyset, \emptyset)$. The message of $\mathit{add}$ operation is of the form $(a,t,p)$, while the message of $\mathit{rem}$ operation is of the form $a \in D$,

\item[-] If $(a,\_,\_) \notin N \wedge (b,\_,\_) \in N \wedge b \notin T$, then $\mathit{do}((N,T),\mathit{add},a,b) = ((E \cup \{ (a,t,p_b) \},T),(a,t,p))$. Here $p_b$ is the time-stamp of $b$, $t = (x+1,r)$, where $x = \mathit{max}\{ y \vert (\_,(y,\_),\_) \in N \}$.

\item[-] If $(a,\_,\_) \notin N$, then $\mathit{do}((N,T),\mathit{add},a,\circ) = ((N \cup \{ (a,t,\circ) \},T),(a,t,\circ))$. If $N = \epsilon$, then $t = (1,r)$; else, $t = (x+1,r)$, where $x = \mathit{max}\{ y \vert (\_,(y,\_),\_) \in N \}$.

\item[-] If $(a,\_,\_) \in N \wedge a \notin T$, then $\mathit{do}((N,T),\mathit{rem},a) = ((N,T \cup \{ a \} ),a)$.

\item[-] $\mathit{do}((N,T),\mathit{read}) = ((N,T),\mathit{list}(N,T))$, and no message is generated.

\item[-] $\mathit{receive}((N,T),(a,t,p)) = (N \cup \{ (a,t,p) \},T)$.

\item[-] $\mathit{receive}((N,T),a) = (N,T \cup \{ a \})$.
\end{itemize}
\end{example} 

\noindent {\bf Semantics of a set of objects:} Given a set $\mathit{Obj}$ of objects, the semantics of $\mathit{Obj}$ is given as a tuple $\llbracket \mathit{Obj} \rrbracket = (\mathit{Config},\mathit{config}_0,\rightarrow_{\mathit{Obj}})$ as in \figurename~\ref{fig:a distributed linearizable history}. 
 
\begin{figure}[ht]
$\mathit{RState} = \cup_{x \in \mathit{Obj}} (\mathbb{R} \rightarrow x.\Sigma)$ 

$\mathit{TState} = \mathit{MessageID} \times \mathbb{MSG} \times \mathbb{R} \times \mathbb{R}$ 

$\mathit{Config} = \mathit{RState} \times \mathit{TState}$ 

$I_t(r) = (\Sigma, \sigma_0, M, \mathit{do},\mathit{receive})$. Here $r \in \mathbb{R}$, $\sigma_0 \in \Sigma$, $\mathit{do}:\Sigma \times \mathbb{M} \times D \rightarrow \Sigma \times D \times (\mathbb{MSG} \cup \{ \emptyset \} )$, and $\mathit{receive}: \Sigma \times \mathbb{MSG} \rightarrow \Sigma$.

\[
\begin{array}{l c}
\bigfrac{ x.\mathit{do}(\sigma,m,a,r) = (\sigma',b,\mathit{msg}), \mathit{unique}(\mathit{msgId}) }
{ (R,T) {\xrightarrow{\mathit{do}(x,m,a,b,r)}} (R[(x,r):\sigma'],T \cup \{ (\mathit{msgId},\mathit{msg},r,r') \vert r' \in \mathbb{R} \setminus \{ r \} \}) } 
\end{array}
\]

\[
\begin{array}{l c}
\bigfrac{ x.\mathit{receive}(\sigma,\mathit{msg}) = \sigma'}
{ (R,T) {\xrightarrow{\mathit{receive}(x,\mathit{msg},r)}} (R[(x,r):\sigma'],T) } 
\end{array}
\] 
\caption{The semantics of multiple objects} 
\label{fig:the semantics of multiple objects}
\end{figure}

A configuration $(R,T)$ contains two parts: $R$ stores the local state of each replica, and $T$ stores the set of messages that has been generated. Let $\mathit{MessageID}$ be the set of message identifiers of message content. A message identifier is used to distinguish multiple messages with same message content. A message is a tuple $(\mathit{msgId},\mathit{msg},r,r')$, where $\mathit{msgId}$ is the identifier of the message content, $\mathit{msg} \in \mathbb{MSG}$ is the message content, $r$ is the sending replica of the message and $r'$ is the destination replica of the message. The first rule in \figurename~\ref{fig:a distributed linearizable history} describes the case when object $x$ at replica $r$ do an operation and (possibly) generate messages. Here $\mathit{unique}$ is a function that ensure $\mathit{msgId}$ is a fresh message identifier. The second rule describes when a replica $r$ receive a message of object $x$.


Let $\mathbb{ACT}$ be the set of actions. An execution of $\llbracket \mathit{Obj} \rrbracket$ is a tuple $e = (E,\mathit{eo},\mathit{ro},\mathit{del})$. Here $E \subseteq \mathbb{ACT}$ is a set of actions, $\mathit{eo} \subseteq E \times E$ is a well-founded, transitive, irreflexive and total order on $E$, $\mathit{ro} \subseteq \mathit{ro}$ is a union of transitive, irreflexive and total orders of actions of same replica, $\mathit{del} \subseteq \mathit{ro}$ is the delivery relation and is defined as follows: $(e_1,e_2) \in \mathit{del}$, if $e_2$ receives the message generated by $e_1$. 

Note that here we do not make any assumption about message delivery: messages can be delivered in any order, a message can be delivery to a replica multiple times, and a message can be never delivered to a replica. The operation-based CRDT assume that each message is delivered to a replica at most once. 





%%% Local Variables:
%%% mode: latex
%%% TeX-master: "draft"
%%% End:
