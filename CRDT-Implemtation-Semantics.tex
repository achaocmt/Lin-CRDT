%!TEX root = draft.tex
%\newcommand{\seqPQ}{\mathsf{SeqPQ}}

\section{CRDT Implementations and Its Semantics}
\label{sec:CRDT implementations and its semantics} 

In this section, we give examples of CRDT implementations and formally defines CRDT implementations as functions between local states. Then, we give the semantics of CRDT implementations. 


\subsection{CRDT Implementations}
\label{subsec:CRDT implementations} 

In optimistic replication algorithms, each client contains a copy of its data, and when a client operations takes effect instantly at its replica without any synchronization, and then broadcast to other replicas. CRDT is a typical kinds of optimistic replication algorithms. 






In practice, there are two kinds of CRDT implementations: operation-based CRDT and state-based CRDT. In operation-based CRDT, each message carries a description of the latest operation of the sending replica. In state-based CRDT, each message carries a description of the local state of the sending replica.





A replicated data type implementation shows how a algorithm works at one replica, including how to perform an operation and send message, as well as how to update the local data when receiving message. Let $\mathbb{MSG}$ be the set of message contents.

\begin{definition}[Replicated Type Implementation]
\label{definition:replicated type implementation}
A replicated type implementation for a type $t = (M,D)$ is a tuple $I_t(r) = (\Sigma, \sigma_0, M, \mathit{do},\mathit{receive})$. Here $r \in \mathbb{R}$, $\sigma_0 \in \Sigma$, $\mathit{do}:\Sigma \times \mathbb{M} \times D \rightarrow \Sigma \times D \times (\mathbb{MSG} \cup \{ \emptyset \} )$, and $\mathit{receive}: \Sigma \times \mathbb{MSG} \rightarrow \Sigma$.
\end{definition}

Here $\Sigma$ is the local state of one replica. $\sigma_0$ is the initial state. $r$ is the replica identifier of current replica, since some algorithms need the current replica identifier to generate time-stamp. When the current local state is $\sigma$ and the client intends to perform a operation of method $m$ with argument $a$, a $\mathit{do}$ action is launched, which update the local states, returns a value, and possibly generate messages. If $m \in \mathbb{U}$, a $\mathit{do}$ action of method $m$ will generate messages; else, if $m \in \mathbb{Q}$, a $\mathit{do}$ action of method $m$ will not generate message. When this replica receives a message of other replica, a $\mathit{receive}$ action will be launched, which updates the current local states according to the message. If a operation has no arguments or return value, or does not generate message, then we can safely omit the corresponding ones in $\mathit{do}$ actions of $I_t$.

In practice, there are two kinds of CRDT implementations: operation-based CRDT and state-based CRDT. In operation-based CRDT, each message carries a description of the latest operation of the sending replica. In state-based CRDT, each message carries a description of the local state of the sending replica.

In the following we give the example of two algorithms: operation-based last-write-win register (LWW-register), and replicated growable array (RGA), which is also operation-based. More algorithms are given in Appendix \ref{sec:appendix definitions of section CRDT implementations and its semantics}.

\begin{example}[LWW-register]
\label{definition:LWW-register}
$I_t(r) = (\Sigma, \sigma_0, M, \mathit{do},\mathit{receive})$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each item of $\Sigma$ is a tuple $(\mathit{data},\mathit{ts})$, where $\mathit{data} \in D$ is the data and $\mathit{ts} \in \mathbb{N} \times \mathbb{R}$ is the time-stamp. $\sigma_0 = (\epsilon, 0)$.

\item[-] Each message is of the form $(\mathit{data},\mathit{ts})$.

\item[-] $\mathit{do}((a,(u,r')),\mathit{write},b) = ((b,(u+1,r)),(b,(u+1,r)))$,

\item[-] $\mathit{do}((a,(u,r')),\mathit{read}) = ((a,(u,r')),a)$,

\item[-] If $u<v \vee (u=v \wedge r' < r'')$, then $\mathit{receive}((a,(u,r')), ((b,(v,r'')))) = (b,(v,r''))$. Else, $\mathit{receive}((a,(u,r')), ((b,(v,r'')))) = (a,(u,r'))$.
\end{itemize}
\end{example}


\begin{example}[RGA]
\label{definition:rga implementation}
In RGA algorithm, a replica store the list as a tree, where the list is obtained by traversing the tree in prefix order. Each node of the tree stores a tuple containing a item of list, a pointer to parent node of the tree, and a time-stamp of the item. The already-deleted items of the tree are stored in tombstone. Here we assume that each item of the list is globally unique.

Formally, each replica stores two parts. The first part is a set $N$ of tuples $(a,t,p)$, where $a \in D$ is a item, $t$ is its unique time-stamp, and $p$ is the time-stamp of its ``parent'' node. The second part is a set $\mathit{Tomb}$ of tombstones, which are set of items removed from the list. Each time-stamp is a tuple $(u,r)$ with $u \in \mathbb{N}$ and $r \in \mathbb{R}$. We define a order $<_{\mathit{ts}}$ between time-stamps, such that $(u_1,r_1) <_{\mathit{ts}} (u_2,r_2)$, if $u_1 < u_2 \vee (u_1 = u_2 \wedge r_1 <_r r_2)$, where $<_r$ is a total-order over $\mathbb{R}$. The elements of $N$ are required to form a tree by following the parent field (a special time-stamp value $\circ$ represents the root). Let $\mathit{list}(N,\mathit{Tomb})$ be the list seen by the local replica, which is a sequences obtained by traversing $N$ in prefix order (children are visited in decreasing time-stamp order) and keeping only items that are not in $\mathit{Tomb}$. In the interface of RGA, we assume that the first item of list is fixed to be $\circ$.

To insert a new item $a$ into list after a existing item $b$ of $N$, we put $(a,t,p_b)$ into $N$, where $p_b$ is the time-stamp of $b$, and t is a time-stamp that is bigger than all time-stamps of $N$. We remove an item $a$ of $N$ by putting $a$ into $\mathit{Tomb}$. To read the list, we return $\mathit{list}(N,\mathit{Tomb})$. The tuples of RGA is defined as follows: $I_t(r) = (\Sigma, \sigma_0, M, \mathit{do},\mathit{receive})$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Each item of $\Sigma$ is a tuple $(N,\mathit{Tomb})$ as above, $\sigma_0 = (\emptyset, \emptyset)$. The message of $\mathit{add}$ operation is of the form $(a,t,p)$, while the message of $\mathit{rem}$ operation is of the form $a \in D$,

\item[-] If $(a,\_,\_) \notin N \wedge (b,\_,\_) \in N \wedge b \notin \mathit{Tomb}$, then $\mathit{do}((N,\mathit{Tomb}),\mathit{add},a,b) = ((E \cup \{ (a,t,p_b) \},\mathit{Tomb}),(a,t,p))$. Here $p_b$ is the time-stamp of $b$, $t = (\mathit{max}\{ u \vert (\_,(u,\_),\_) \in N \}+1,r)$.

\item[-] If $(a,\_,\_) \notin N$, then $\mathit{do}((N,\mathit{Tomb}),\mathit{add},a,\circ) = ((N \cup \{ (a,t,\circ) \},\mathit{Tomb}),(a,t,\circ))$. If $N = \epsilon$, then $t = (1,r)$; else, $t = (\mathit{max}\{ u \vert (\_,(u,\_),\_) \in N \}+1,r)$.

\item[-] If $(a,\_,\_) \in N \wedge a \notin \mathit{Tomb}$, then $\mathit{do}((N,\mathit{Tomb}),\mathit{rem},a) = ((N,\mathit{Tomb} \cup \{ a \} ),a)$.

\item[-] $\mathit{do}((N,\mathit{Tomb}),\mathit{read}) = ((N,\mathit{Tomb}),\mathit{list}(N,\mathit{Tomb}))$, and no message is generated.

\item[-] $\mathit{receive}((N,\mathit{Tomb}),(a,t,p)) = (N \cup \{ (a,t,p) \},\mathit{Tomb})$.

\item[-] $\mathit{receive}((N,\mathit{Tomb}),a) = (N,\mathit{Tomb} \cup \{ a \})$.
\end{itemize}
\end{example}

\noindent {\bf Semantics of a set of objects:} Given a set $\mathit{Obj}$ of objects, the semantics of $\mathit{Obj}$ is given as a tuple $\llbracket \mathit{Obj} \rrbracket = (\mathit{Config},\mathit{config}_0,\rightarrow)$ as in \figurename~\ref{fig:a distributed linearizable history}.

\begin{figure}[ht]
$\mathit{RState} = \cup_{x \in \mathit{Obj}} (\mathbb{R} \rightarrow x.\Sigma)$

$\mathit{TState} = \mathbb{MID} \times \mathbb{MSG} \times \mathbb{R} \times \mathbb{R}$

$\mathit{Config} = \mathit{RState} \times \mathit{TState}$, $\mathit{config}_0 \in \mathit{Config}$.


\[
\begin{array}{l c}
\bigfrac{ R(x,r) = \sigma, x(r).\mathit{do}(\sigma,m,a,r) = (\sigma',b,\mathit{msg}), \mathit{unique}(\mathit{msgId}) }
{ (R,T) {\xrightarrow{\mathit{do}(x,m,a,b,r)}} (R[(x,r):\sigma'],T \cup \{ (\mathit{msgId},\mathit{msg},r,r') \vert r' \in \mathbb{R} \setminus \{ r \} \}) }
\end{array}
\]

\[
\begin{array}{l c}
\bigfrac{ R(x,r) = \sigma, x.\mathit{receive}(\sigma,\mathit{msg}) = \sigma',(\_,\mathit{msg},\_,r) \in T}
{ (R,T) {\xrightarrow{\mathit{receive}(x,\mathit{msg},r)}} (R[(x,r):\sigma'],T) }
\end{array}
\]
\caption{The semantics of multiple objects}
\label{fig:the semantics of multiple objects}
\end{figure}

A configuration $(R,T)$ contains two parts: $R$ stores the local state of each replica, and $T$ stores the set of messages that has been generated. Let $\mathbb{MID}$ be the set of message identifiers of message content. A message identifier is used to distinguish multiple messages with same message content that are generated during execution. A message is a tuple $(\mathit{msgId},\mathit{msg},r,r')$, where $\mathit{msgId} \in \mathbb{MID}$ is the identifier of the message content, $\mathit{msg} \in \mathbb{MSG}$ is the message content, $r$ is the sending replica of the message and $r'$ is the destination replica of the message. The first rule in \figurename~\ref{fig:a distributed linearizable history} describes the case when object $x$ at replica $r$ do an operation and (possibly) generate messages. Here $\mathit{unique}$ is a function that ensure $\mathit{msgId}$ is a fresh message identifier. The second rule describes the case when a replica $r$ receive a message of object $x$. Note that each configuration contains all the message it ever generated.

$\llbracket \mathit{Obj} \rrbracket$ may be not precise enough, since it does not make any assumption about message delivery: Messages can be delivered in any order, a message can be delivery to a replica multiple times, and a message can be never delivered to a replica. This fits the assumption of state-based CRDT. However, the operation-based CRDT indeed have assumption about message delivery: each message is delivered to a replica at most once. Many operation-based CRDT has an additional assumption called causal-delivery: if operation $o_1$ happens before operation $o_2$, then it can not be the case that some replica receives the message of $o_2$ while it does not receive the message of $o_1$ yet. In latter section we will discuss how to combine objects with different requirements of message delivery.

In the next section, we will prove the correctness of individual objects. Let us propose the semantics for individual objects for different kinds of CRDT as follows.

The semantics of state-based object $x$ is given as follows: $\llbracket x \rrbracket_{s} = (\mathit{Config},\mathit{config}_0,\rightarrow)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathit{RState} = \mathbb{R} \rightarrow \Sigma$,

\item[-] $\mathit{TState} = \mathbb{MID} \times \mathbb{MSG} \times \mathbb{R} \times \mathbb{R} \times \{ \mathit{true},\mathit{false} \}$. Here $\mathit{true}$ represents that the message is generated and is not delivered yet, while $\mathit{false}$ represents that this message has already been delivered at least once.

%\item[-] $\mathit{MsgHB} = (\mathbb{MID} \times \mathbb{MID}) \cup (\mathbb{MID} \times \mathbb{R})$. $(m_1,m_2) \in \mathit{MsgHB}$ represents that the operation of message $o_1$ happens before the operation of message $o_2$; $(m_1,r') \in \mathit{MsgHB}$ means that $m_1$ is delivered to replica $r'$ but after that replica $r'$ does not launch any operation.

\item[-] $\mathit{Config} = \mathit{RState} \times \mathit{TState}$.

\item[-]

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
     R(r) = \sigma, \mathit{do}(\sigma,m,a,r) = (\sigma',b,\mathit{msg}), \mathit{unique}(\mathit{msgId})
   \end{array}}
     {(R,T) {\xrightarrow{\mathit{do}(m,a,b,r)}} (R[r:\sigma'],T \cup \{ (\mathit{msgId},\mathit{msg},r,r',\mathit{true}) \vert r' \in \mathbb{R} \setminus \{ r \} \})}
\end{array}$

\item[-]

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
      R(r) = \sigma, \mathit{receive}(\sigma,\mathit{msg}) = \sigma', \exists \mathit{msgId},(\mathit{msgId},\mathit{msg},r',r,\mathit{true}) \in T
   \end{array}}
     {(R,T) {\xrightarrow{\mathit{receive}(\mathit{msg},r)}} (R[r:\sigma'],T[(\mathit{msgId},\mathit{msg},r',r):\mathit{false}])}
\end{array}$
\end{itemize}



The semantics of operation-based object $x$ is given as follows: $\llbracket x \rrbracket_{\mathit{op}} = (\mathit{Config},\mathit{config}_0,\rightarrow)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathit{RState} = \mathbb{R} \rightarrow \Sigma$,

\item[-] $\mathit{TState} = \mathbb{MID} \times \mathbb{MSG} \times \mathbb{R} \times \mathbb{R}$.

\item[-] $\mathit{Config} = \mathit{RState} \times \mathit{TState}$.

\item[-]

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
     R(r) = \sigma, \mathit{do}(\sigma,m,a,r) = (\sigma',b,\mathit{msg}), \mathit{unique}(\mathit{msgId})
   \end{array}}
     {(R,T) {\xrightarrow{\mathit{do}(m,a,b,r)}} (R[r:\sigma'],T \cup \{ (\mathit{msgId},\mathit{msg},r,r') \vert r' \in \mathbb{R} \setminus \{ r \} \})}
\end{array}$

\item[-] When a message is delivered, we directly remove it from $T$. This makes a message be delivered at most once.

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
      R(r) = \sigma, \mathit{receive}(\sigma,\mathit{msg}) = \sigma', \exists \mathit{msgId},(\mathit{msgId},\mathit{msg},r',r) \in T
   \end{array}}
     {(R,T,\mathit{MsgHB}) {\xrightarrow{\mathit{receive}(\mathit{msg},r)}} (R,T \setminus \{ (\mathit{msgId},\mathit{msg},r',r) \} )}
\end{array}$
\end{itemize}

To deal with operation-based object with causal-delivery, we record the happen-before relation $\mathit{MsgHB}$ and the message deliver relation $\mathit{MsgDel}$ in each configuration. $(m_1,m_2) \in \mathit{MsgHB}$ represents that $m_1$ happens before $m_2$; $(m_1,r') \in \mathit{MsgDel}$ means that $m_1$ is already delivered to replica $r'$, but after that replica $r'$ does not launch any operation. With $\mathit{MsgHB}$, only minimal messages w.r.t $\mathit{MsgHB}$ can be delivered. The semantics $\llbracket x \rrbracket_{\mathit{cd}}$ of operation-based object $x$ with causal-delivery is given as $\llbracket x \rrbracket_{\mathit{cd}} = (\mathit{Config},\mathit{config}_0,\rightarrow)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathit{RState} = \mathbb{R} \rightarrow \Sigma$,

\item[-] $\mathit{TState} = \mathbb{MID} \times \mathbb{MSG} \times \mathbb{R} \times \mathbb{R}$.

\item[-] $\mathit{MsgHB} \subseteq \mathbb{MID} \times \mathbb{MID}$.

\item[-] $\mathit{MsgDel}\subseteq \mathbb{MID} \times \mathbb{R}$.

\item[-] $\mathit{MsgHB}$ is acyclic. If $(i,r) \in \mathit{MsgDel}$, then there does not exists message $j$ that are launched by replica $r$ and $(i,j) \in \mathit{MsgHB}$.

\item[-] $\mathit{Config} = \mathit{RState} \times \mathit{TState} \times \mathit{MsgHB} \times \mathit{MsgDel}$.

\item[-]

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
     R(r) = \sigma, \mathit{do}(\sigma,m,a,r) = (\sigma',b,\mathit{msg}), \mathit{unique}(\mathit{msgId}), \\
     \mathit{msgHB}' = \mathit{upd}(\mathit{msgHB},\mathit{msgID},r) ,\mathit{msgDel}' = \mathit{upd}(\mathit{msgDel},\mathit{msgID},r)
   \end{array}}
     {(R,T,\mathit{msgHB},\mathit{msgDel}) {\xrightarrow{\mathit{do}(m,a,b,r)}} (R[r:\sigma'],T \cup \{ (\mathit{msgId},\mathit{msg},r,r') \vert r' \in \mathbb{R} \setminus \{ r \} \}, \mathit{msgHB}',\mathit{msgDel}')}
\end{array}$

\item[-]

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
      R(r) = \sigma, \mathit{receive}(\sigma,\mathit{msg}) = \sigma', \exists \mathit{msgId},(\mathit{msgId},\mathit{msg},r',r) \in T, \\
      \mathit{msgDel}' = \mathit{msgDel} \cup \{ (\mathit{msgId},r) \}.
   \end{array}}
     {(R,T,\mathit{msgHB},\mathit{msgDel}) {\xrightarrow{\mathit{receive}(\mathit{msg},r)}} (R,T \setminus \{ (\mathit{msgId},\mathit{msg},r',r),\mathit{msgHB},\mathit{msgDel}' \} )}
\end{array}$
\end{itemize}

Let $\mathit{upd}(\mathit{msgHB},\mathit{msgID},r)$ be the transitive closure of $\mathit{msgHB} \cup \{ (i,\mathit{msgID}) \vert i$ is launched in replica $r \vee (i,r) \in \mathit{msgDel}  \}$. Let $\mathit{upd}(\mathit{msgDel},\mathit{msgID},r) = \mathit{msgDel} \setminus \{ (i,r) \in \mathit{msgDel} \}$.



A action label is in the form of $\mathit{do}(x,m,a,b,r)$ or $\mathit{receive}(x,\mathit{msg},r)$, where $x \in \mathbb{OBJ}$, $m \in \mathbb{M}$, $a,b \in \mathbb{D}$, $r \in \mathbb{R}$, $\mathit{msg} \in \mathbb{MSG}$. Let $\mathbb{AID}$ be the set of action identifier. An action $a$ is a tuple $(l,i)$ with action label $l$ and action identifier $i$. Let $\mathit{ACT}$ be the set of actions.

An execution of $\llbracket \mathit{Obj} \rrbracket$ is a tuple $e = (E,\mathit{eo},\mathit{ro},\mathit{del})$. Here $E \subseteq \mathbb{ACT}$ is a set of actions, $\mathit{eo} \subseteq E \times E$ is a well-founded, transitive, irreflexive and total order on $E$, $\mathit{ro} \subseteq \mathit{eo}$ is a union of transitive, irreflexive and total orders of actions of same replica, $\mathit{del} \subseteq E \times E$ is the delivery relation. Given a execution, it is obvious to construct its history.

Given a sequence of transitions $\mathit{config}_0  {\xrightarrow{\alpha_1}} \mathit{config}_1 \ldots$ of $\llbracket \mathit{Obj} \rrbracket$, its execution $(E,\mathit{eo}$, $\mathit{ro},\mathit{del})$ is generated as follows: $E$ is the set $\{ \alpha_1,\ldots \}$; $\mathit{eo}$ is the total order of $\alpha_1,\ldots$; $\mathit{ro}$ is the projection of $\mathit{eo}$ over each replica; $(a_1,a_2) \in \mathit{del}$, if $a_2$ is a receive action and its receives the message generated by $e_1$.



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "draft"
%%% End:
