%!TEX root = draft.tex
%\newcommand{\seqPQ}{\mathsf{SeqPQ}}

\section{CRDT Implementations and Its Semantics}
\label{sec:CRDT implementations and its semantics}

In this section, we give examples of CRDT implementations and formally defines CRDT implementations as functions between local states. Then, we give the semantics of CRDT implementations.


\subsection{CRDT Implementations}
\label{subsec:CRDT implementations}

In optimistic replication algorithms, each client contains a copy of data structure; a client operations takes effect instantly at its replica without any synchronization, and then broadcast to other replicas and got applied. CRDT is a typical kinds of optimistic replication algorithms.

In practice, there are two kinds of CRDT implementations: operation-based CRDT and state-based CRDT.

In state-based CRDT, an update operation will send the modified local state will be send into other replica. The state-based PN-counter is an example of state-based CRDT algorithms and is shown below. Keyword payload indicate the local state, and keyword initial specifies the initial value of local state. Function $myID()$ returns the current replica identifier, and $reps()$ returns the number of replicas of the distributed system. Vector $P$ (resp., $N$) is a vector such that $P[i]$ (resp., $N[i]$) is the number of increase that is generated by replica $i$ and is observed by current replica. When the current replica receive a message of modified payload $Z$, it use function $merge()$ to update the current local state. $merge$ takes the maximum of each replica in the vector. This algorithm assumes that the set of replica is already known.

\renewcommand{\algorithmcfname}{CRDT}
\noindent
%\begin{minipage}{.5\textwidth}
\noindent\begin{algorithm}[H]
$\mathit{payload}$ integer[reps()] P, integer[reps()] N; \\
$\mathit{initial}$ [0,\ldots,0],[0,\ldots,0]; \\

$inc()$ \\
%\ \ \ \ let \ g = myID();\\
\ \ \ \ P[myID()] = P[myID()] + 1; \\

$dec()$ \\
%\ \ \ \ let \ g = myID();\\
\ \ \ \ N[myID()] = N[myID()] + 1; \\

$read()$ \\
\ \ \ \ \KwRet $\Sigma_{i}^{n} P[i] - \Sigma_{i}^{n} N[i]$; \\

$merge(Z)$ \\
\ \ \ \ $\forall i$, $P[i] = \mathit{max}(P[i],Z.P[i])$; \\
\ \ \ \ $\forall i$, $N[i] = \mathit{max}(N[i],Z.N[i])$; \\
\caption{State-based PN-counter}
\label{Method1}
\end{algorithm}

In operation-based CRDT, an update operation will send a description of this operation into other replica. Here we take a more complex algorithm, replicated growable array (RGA), as an example of operation-based CRDT and it is shown below.

\renewcommand{\algorithmcfname}{CRDT}
\noindent
%\begin{minipage}{.5\textwidth}
\noindent\begin{algorithm}[H]
$\mathit{payload}$ TI-tree N, set T; \\
$\mathit{initial}$ $\emptyset$,$\emptyset$; \\

$add(a,b)$ \\
\ \ $\mathit{atSource}$: \\
\ \ \ \ $\mathit{pre}$: \ $b = \circ \vee ( b \neq \circ \wedge (b,\_,\_) \in N \wedge b \notin T)$ \\

%\ \ \ \ \If {$N = \emptyset$}
%    { \ \ \ \ let \ $ts_a$ = (myID(),1); \\ }
%\ \ \ \ \Else
%    {\ \ \ \ let \ $ts_a$ = (myID(),$\mathit{max}\{ c' \vert (\_,(\_,c'),\_) \in N \} +1$); \\ }

%\ \ \ \ \If {$b = \circ$}
%    { \ \ \ \ let \ $ts_b$ = (0,0); \\ }
%\ \ \ \ \Else
%    { \ \ \ \ let \ $ts_b$ be time-stamp of $b$ in $N$; \\ }

\ \ \ \ let \ $ts_a$ = ($N = \emptyset$) ? (1,myID()) ! ($\mathit{max}\{ c' \vert (\_,(\_,c'),\_) \in N \} +1$,myID()); \\
\ \ \ \ let \ $ts_b$ = ($b = \circ$) ? (0,0) ! (the time-stamp of $b$ in $N$); \\

\ \ $\mathit{downstream}(a,ts_a,ts_b)$: \\
\ \ \ \ $\mathit{pre}$: \ $b = \circ \vee ( b \neq \circ \wedge (b,ts_b,\_) \in N)$ \\

\ \ \ \ $N = N \cup \{ (a,ts_a,ts_b) \}$.


$rem(a)$ \\
\ \ $\mathit{atSource}$: \\
\ \ \ \ $\mathit{pre}$: \ $a \neq \circ \wedge (a,\_,\_) \in N \wedge a \notin T$ \\

\ \ $\mathit{downstream}(a)$: $\mathit{pre}$ \ $a \neq \circ \wedge (a,\_,\_) \in N)$

\ \ \ \ $T = T \cup \{ a \}$.

$read()$ \\
\ \ \ \ \KwRet $\mathit{trans}(N,T)$; \\

\caption{RGA}
\label{Method1}
\end{algorithm}

Each update operation of operation-based CRDT ie executed with two phases: Its first phase, marked $\mathit{atSource}$, is local to the source replica. It is enabled if its (optional) pre-condition, marked $\mathit{pre}$, is true currently in local state. It generates the information to be delivered. Its second phase, marked $\mathit{downstream}$, executed immediate after the source replica, and asynchronously at other replica when they receive the message of this operation. It is enabled if its (optional) pre-condition is true. The argument of $\mathit{downstream}$ is the content of message to be delivered. 

In RGA algorithm, a replica store the list as a timestamp insertion tree (TI-tree) $N$, and stores the deleted items in tombstone $T$. A TI-tree $N$ is a set of tuples $(a,t,p)$, where $a$ is a item, $t$ is its unique time-stamp, and $p$ is the time-stamp of its ``parent'' node. Each time-stamp is a tuple $(c,r)$ with $c \in \mathbb{N}$ and $r \in \mathbb{R}$. A order $<_{\mathit{ts}}$ between time-stamps is defined, such that $(c_1,r_1) <_{\mathit{ts}} (c_2,r_2)$, if $c_1 < c_2 \vee (c_1 = c_2 \wedge r_1 <_r r_2)$, where $<_r$ is a total-order over $\mathbb{R}$. There is a pre-existed item $\circ$ of TI-tree with time stamp $(0,0)$, which are considered as the root of the tree. Each element of $N$ should have unique item and time stamp, and the elements of $N$ are required to form a tree by following the parent field. The tombstone $T$ is a set of items and records items been removed from the list. Function $\mathit{trans}(N,T)$ returns the list seen by the local replica, which is a sequences obtained by traversing $N$ in prefix order (children are visited in decreasing time-stamp order) and keeping only items that are not in $T$.

To enable formally semantics and verification of CRDT algorithms, it is necessary to give formal definition of CRDT-algorithms. Let $\mathbb{MSG}$ be the set of message contents, such as $inc$ of state-based PN-counter, or $(a,ts_a,ts_b)$ of RGA. Then, CRDT implementations are defined as follows.

\begin{definition}[CRDT implementations]
\label{definition:CRDT implementations}
A CRDT implementation for a type $t = (M,D)$ is a tuple $I_t(r) = (\Sigma, \sigma_0, \mathit{Msg}, \mathit{do},\mathit{receive})$. Here $r \in \mathbb{R}$, $\sigma_0 \in \Sigma$, $\mathit{do}:\Sigma \times \mathbb{M} \times D \rightarrow \Sigma \times D \times (\mathbb{MSG} \cup \{ \emptyset \} )$, and $\mathit{receive}: \Sigma \times \mathbb{MSG} \rightarrow \Sigma$.
\end{definition}

Here $\Sigma$ is the set of local states and $\sigma_0$ is the initial state. $r$ is the replica identifier of current replica. The reason of containing $r$ is that, some algorithms need the current replica identifier to generate time-stamp. When the current local state is $\sigma$ and the client intends to perform a operation of method $m$ with argument $a$, a $\mathit{do}$ action is launched, which update the local states, returns a value, and possibly generate messages. A $\mathit{do}$ action of update method will generate messages, while a $\mathit{do}$ action of query method will not generate message. When this replica receives a message of other replica, a $\mathit{receive}$ action will be launched, which updates the current local states according to the message. If a operation has no arguments or return value, or does not generate message, then we can safely omit the corresponding tuples in $\mathit{do}$ actions.

The following is an example of formal definition of state-based PN-counter. The formal definition of more CRDT implementations are given in Appendix \ref{sec:appendix definitions of section CRDT implementations and its semantics}.

\begin{example}[state-based PN-counter]
\label{definition:state-based PN-counter}
$I_t(r) = (\Sigma, \sigma_0, \mathit{Msg}, \mathit{do},\mathit{receive})$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\Sigma = \{ (P,N) \vert$, $P$ and $N$ are vector of integers with same length $\}$. $\sigma_0 = (P_0,N_0)$, where $P_0$ and $N_0$ maps each index into $0$.

\item[-] $\mathit{Msg} = \Sigma$.

\item[-] $\mathit{do}((P,N),\mathit{inc}) = ((P[r:P[r]+1],N),(P[r:P[r]+1],N))$,

\item[-] $\mathit{do}((P,N),\mathit{dec}) = ((P,N[r:N[r]+1]),(P,N[r:N[r]+1]))$,

\item[-] $\mathit{receive}((P,N),(P',N')) = (\lambda s. \mathit{max}\{  P[s], N'[s] \}, \mathit{max}\{  N[s], N'[s] \},)$,
\end{itemize}
\end{example}





\subsection{Semantics of CRDT Implementations}
\label{subsec:CRDT implementations} 

\noindent {\bf Semantics of state-based CRDT implementation:} Given a state-based CRDT implementation $x$, its semantics is given as an LTS $\llbracket x \rrbracket_{s} = (\mathit{Config},\mathit{config}_0,\rightarrow)$ in \autoref{fig:the semantics of state-based CRDT implementation}. 

\begin{figure}[ht]
$\mathit{RState} = \mathbb{R} \rightarrow \Sigma$, 

$\mathit{TState} = \mathbb{MID} \times \mathbb{MSG} \times \mathbb{R}$. 

$\mathit{Config} = \mathit{RState} \times \mathit{TState}$. 


\[
\begin{array}{l c}
\bigfrac{ R(r) = \sigma, \mathit{do}(\sigma,m,a,r) = (\sigma',b,\mathit{msg}), \mathit{unique}(\mathit{msgId}) }
{ (R,T) {\xrightarrow{\mathit{do}(m,a,b,r)}} (R[r:\sigma'],T \cup \{ (\mathit{msgId},\mathit{msg},r,r',\mathit{true}) \vert r' \in \mathbb{R} \setminus \{ r \} \}) }
\end{array}
\]

\[
\begin{array}{l c}
\bigfrac{ R(r) = \sigma, \mathit{receive}(\sigma,\mathit{msg}) = \sigma', \exists \mathit{msgId},(\mathit{msgId},\mathit{msg},r',r,\mathit{true}) \in T }
{ (R,T) {\xrightarrow{\mathit{receive}(\mathit{msg},r)}} (R[r:\sigma'],T[(\mathit{msgId},\mathit{msg},r',r):\mathit{false}]) }
\end{array}
\]
\caption{The semantics of state-based CRDT implementation}
\label{fig:the semantics of state-based CRDT implementation}
\end{figure} 


A configuration $(R,T)$ contains two parts: $R$ stores the local state of each replica, and $T$ stores the set of messages that has been generated. Let $\mathbb{MID}$ be the set of message identifiers, which are used to distinguish multiple messages with same message content that are generated during execution. A message is a tuple $(\mathit{msgId},\mathit{msg},r')$, where $\mathit{msgId} \in \mathbb{MID}$ is the identifier of the message content, $\mathit{msg} \in \mathbb{MSG}$ is the message content, and $r'$ is the destination replica of the message. The first rule in \autoref{fig:the semantics of state-based CRDT implementation} describes the case when $x$ does an operation in replica $r$ and (possibly) generate messages. Here $\mathit{unique}$ is a function that ensure $\mathit{msgId}$ being a fresh message identifier. The second rule describes the case when a replica $r$ receive a message. Note that $\llbracket x \rrbracket_{s}$ does not make any assumption about message delivery: Messages can be delivered in any order, a message can be delivery to a replica multiple times, and a message can be never delivered to a replica. Therefore, each configuration records all the message it ever generated. 









$\llbracket \mathit{Obj} \rrbracket$ may be not precise enough, since it does not make any assumption about message delivery: Messages can be delivered in any order, a message can be delivery to a replica multiple times, and a message can be never delivered to a replica. This fits the assumption of state-based CRDT. However, the operation-based CRDT indeed have assumption about message delivery: each message is delivered to a replica at most once. Many operation-based CRDT has an additional assumption called causal-delivery: if operation $o_1$ happens before operation $o_2$, then it can not be the case that some replica receives the message of $o_2$ while it does not receive the message of $o_1$ yet. In latter section we will discuss how to combine objects with different requirements of message delivery.

In the next section, we will prove the correctness of individual objects. Let us propose the semantics for individual objects for different kinds of CRDT as follows.

The semantics of state-based object $x$ is given as follows: $\llbracket x \rrbracket_{s} = (\mathit{Config},\mathit{config}_0,\rightarrow)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathit{RState} = \mathbb{R} \rightarrow \Sigma$,

\item[-] $\mathit{TState} = \mathbb{MID} \times \mathbb{MSG} \times \mathbb{R} \times \mathbb{R} \times \{ \mathit{true},\mathit{false} \}$. Here $\mathit{true}$ represents that the message is generated and is not delivered yet, while $\mathit{false}$ represents that this message has already been delivered at least once.

%\item[-] $\mathit{MsgHB} = (\mathbb{MID} \times \mathbb{MID}) \cup (\mathbb{MID} \times \mathbb{R})$. $(m_1,m_2) \in \mathit{MsgHB}$ represents that the operation of message $o_1$ happens before the operation of message $o_2$; $(m_1,r') \in \mathit{MsgHB}$ means that $m_1$ is delivered to replica $r'$ but after that replica $r'$ does not launch any operation.

\item[-] $\mathit{Config} = \mathit{RState} \times \mathit{TState}$.

\item[-]

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
     R(r) = \sigma, \mathit{do}(\sigma,m,a,r) = (\sigma',b,\mathit{msg}), \mathit{unique}(\mathit{msgId})
   \end{array}}
     {(R,T) {\xrightarrow{\mathit{do}(m,a,b,r)}} (R[r:\sigma'],T \cup \{ (\mathit{msgId},\mathit{msg},r,r',\mathit{true}) \vert r' \in \mathbb{R} \setminus \{ r \} \})}
\end{array}$

\item[-]

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
      R(r) = \sigma, \mathit{receive}(\sigma,\mathit{msg}) = \sigma', \exists \mathit{msgId},(\mathit{msgId},\mathit{msg},r',r,\mathit{true}) \in T
   \end{array}}
     {(R,T) {\xrightarrow{\mathit{receive}(\mathit{msg},r)}} (R[r:\sigma'],T[(\mathit{msgId},\mathit{msg},r',r):\mathit{false}])}
\end{array}$
\end{itemize}



The semantics of operation-based object $x$ is given as follows: $\llbracket x \rrbracket_{\mathit{op}} = (\mathit{Config},\mathit{config}_0,\rightarrow)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathit{RState} = \mathbb{R} \rightarrow \Sigma$,

\item[-] $\mathit{TState} = \mathbb{MID} \times \mathbb{MSG} \times \mathbb{R} \times \mathbb{R}$.

\item[-] $\mathit{Config} = \mathit{RState} \times \mathit{TState}$.

\item[-]

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
     R(r) = \sigma, \mathit{do}(\sigma,m,a,r) = (\sigma',b,\mathit{msg}), \mathit{unique}(\mathit{msgId})
   \end{array}}
     {(R,T) {\xrightarrow{\mathit{do}(m,a,b,r)}} (R[r:\sigma'],T \cup \{ (\mathit{msgId},\mathit{msg},r,r') \vert r' \in \mathbb{R} \setminus \{ r \} \})}
\end{array}$

\item[-] When a message is delivered, we directly remove it from $T$. This makes a message be delivered at most once.

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
      R(r) = \sigma, \mathit{receive}(\sigma,\mathit{msg}) = \sigma', \exists \mathit{msgId},(\mathit{msgId},\mathit{msg},r',r) \in T
   \end{array}}
     {(R,T,\mathit{MsgHB}) {\xrightarrow{\mathit{receive}(\mathit{msg},r)}} (R,T \setminus \{ (\mathit{msgId},\mathit{msg},r',r) \} )}
\end{array}$
\end{itemize}

To deal with operation-based object with causal-delivery, we record the happen-before relation $\mathit{MsgHB}$ and the message deliver relation $\mathit{MsgDel}$ in each configuration. $(m_1,m_2) \in \mathit{MsgHB}$ represents that $m_1$ happens before $m_2$; $(m_1,r') \in \mathit{MsgDel}$ means that $m_1$ is already delivered to replica $r'$, but after that replica $r'$ does not launch any operation. With $\mathit{MsgHB}$, only minimal messages w.r.t $\mathit{MsgHB}$ can be delivered. The semantics $\llbracket x \rrbracket_{\mathit{cd}}$ of operation-based object $x$ with causal-delivery is given as $\llbracket x \rrbracket_{\mathit{cd}} = (\mathit{Config},\mathit{config}_0,\rightarrow)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathit{RState} = \mathbb{R} \rightarrow \Sigma$,

\item[-] $\mathit{TState} = \mathbb{MID} \times \mathbb{MSG} \times \mathbb{R} \times \mathbb{R}$.

\item[-] $\mathit{MsgHB} \subseteq \mathbb{MID} \times \mathbb{MID}$.

\item[-] $\mathit{MsgDel}\subseteq \mathbb{MID} \times \mathbb{R}$.

\item[-] $\mathit{MsgHB}$ is acyclic. If $(i,r) \in \mathit{MsgDel}$, then there does not exists message $j$ that are launched by replica $r$ and $(i,j) \in \mathit{MsgHB}$.

\item[-] $\mathit{Config} = \mathit{RState} \times \mathit{TState} \times \mathit{MsgHB} \times \mathit{MsgDel}$.

\item[-]

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
     R(r) = \sigma, \mathit{do}(\sigma,m,a,r) = (\sigma',b,\mathit{msg}), \mathit{unique}(\mathit{msgId}), \\
     \mathit{msgHB}' = \mathit{upd}(\mathit{msgHB},\mathit{msgID},r) ,\mathit{msgDel}' = \mathit{upd}(\mathit{msgDel},\mathit{msgID},r)
   \end{array}}
     {(R,T,\mathit{msgHB},\mathit{msgDel}) {\xrightarrow{\mathit{do}(m,a,b,r)}} (R[r:\sigma'],T \cup \{ (\mathit{msgId},\mathit{msg},r,r') \vert r' \in \mathbb{R} \setminus \{ r \} \}, \mathit{msgHB}',\mathit{msgDel}')}
\end{array}$

\item[-]

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
      R(r) = \sigma, \mathit{receive}(\sigma,\mathit{msg}) = \sigma', \exists \mathit{msgId},(\mathit{msgId},\mathit{msg},r',r) \in T, \\
      \mathit{msgDel}' = \mathit{msgDel} \cup \{ (\mathit{msgId},r) \}.
   \end{array}}
     {(R,T,\mathit{msgHB},\mathit{msgDel}) {\xrightarrow{\mathit{receive}(\mathit{msg},r)}} (R,T \setminus \{ (\mathit{msgId},\mathit{msg},r',r),\mathit{msgHB},\mathit{msgDel}' \} )}
\end{array}$
\end{itemize}

Let $\mathit{upd}(\mathit{msgHB},\mathit{msgID},r)$ be the transitive closure of $\mathit{msgHB} \cup \{ (i,\mathit{msgID}) \vert i$ is launched in replica $r \vee (i,r) \in \mathit{msgDel}  \}$. Let $\mathit{upd}(\mathit{msgDel},\mathit{msgID},r) = \mathit{msgDel} \setminus \{ (i,r) \in \mathit{msgDel} \}$.



A action label is in the form of $\mathit{do}(x,m,a,b,r)$ or $\mathit{receive}(x,\mathit{msg},r)$, where $x \in \mathbb{OBJ}$, $m \in \mathbb{M}$, $a,b \in \mathbb{D}$, $r \in \mathbb{R}$, $\mathit{msg} \in \mathbb{MSG}$. Let $\mathbb{AID}$ be the set of action identifier. An action $a$ is a tuple $(l,i)$ with action label $l$ and action identifier $i$. Let $\mathit{ACT}$ be the set of actions.

An execution of $\llbracket \mathit{Obj} \rrbracket$ is a tuple $e = (E,\mathit{eo},\mathit{ro},\mathit{del})$. Here $E \subseteq \mathbb{ACT}$ is a set of actions, $\mathit{eo} \subseteq E \times E$ is a well-founded, transitive, irreflexive and total order on $E$, $\mathit{ro} \subseteq \mathit{eo}$ is a union of transitive, irreflexive and total orders of actions of same replica, $\mathit{del} \subseteq E \times E$ is the delivery relation. Given a execution, it is obvious to construct its history.

Given a sequence of transitions $\mathit{config}_0  {\xrightarrow{\alpha_1}} \mathit{config}_1 \ldots$ of $\llbracket \mathit{Obj} \rrbracket$, its execution $(E,\mathit{eo}$, $\mathit{ro},\mathit{del})$ is generated as follows: $E$ is the set $\{ \alpha_1,\ldots \}$; $\mathit{eo}$ is the total order of $\alpha_1,\ldots$; $\mathit{ro}$ is the projection of $\mathit{eo}$ over each replica; $(a_1,a_2) \in \mathit{del}$, if $a_2$ is a receive action and its receives the message generated by $e_1$.















\forget{
\noindent {\bf Semantics of a set of objects:} Given a set $\mathit{Obj}$ of objects, the semantics of $\mathit{Obj}$ is given as a tuple $\llbracket \mathit{Obj} \rrbracket = (\mathit{Config},\mathit{config}_0,\rightarrow)$ as in \autoref{fig:a distributed linearizable history}.

\begin{figure}[ht]
$\mathit{RState} = \cup_{x \in \mathit{Obj}} (\mathbb{R} \rightarrow x.\Sigma)$

$\mathit{TState} = \mathbb{MID} \times \mathbb{MSG} \times \mathbb{R} \times \mathbb{R}$

$\mathit{Config} = \mathit{RState} \times \mathit{TState}$, $\mathit{config}_0 \in \mathit{Config}$.


\[
\begin{array}{l c}
\bigfrac{ R(x,r) = \sigma, x(r).\mathit{do}(\sigma,m,a,r) = (\sigma',b,\mathit{msg}), \mathit{unique}(\mathit{msgId}) }
{ (R,T) {\xrightarrow{\mathit{do}(x,m,a,b,r)}} (R[(x,r):\sigma'],T \cup \{ (\mathit{msgId},\mathit{msg},r,r') \vert r' \in \mathbb{R} \setminus \{ r \} \}) }
\end{array}
\]

\[
\begin{array}{l c}
\bigfrac{ R(x,r) = \sigma, x.\mathit{receive}(\sigma,\mathit{msg}) = \sigma',(\_,\mathit{msg},\_,r) \in T}
{ (R,T) {\xrightarrow{\mathit{receive}(x,\mathit{msg},r)}} (R[(x,r):\sigma'],T) }
\end{array}
\]
\caption{The semantics of multiple objects}
\label{fig:the semantics of multiple objects}
\end{figure}

A configuration $(R,T)$ contains two parts: $R$ stores the local state of each replica, and $T$ stores the set of messages that has been generated. Let $\mathbb{MID}$ be the set of message identifiers of message content. A message identifier is used to distinguish multiple messages with same message content that are generated during execution. A message is a tuple $(\mathit{msgId},\mathit{msg},r,r')$, where $\mathit{msgId} \in \mathbb{MID}$ is the identifier of the message content, $\mathit{msg} \in \mathbb{MSG}$ is the message content, $r$ is the sending replica of the message and $r'$ is the destination replica of the message. The first rule in \autoref{fig:a distributed linearizable history} describes the case when object $x$ at replica $r$ do an operation and (possibly) generate messages. Here $\mathit{unique}$ is a function that ensure $\mathit{msgId}$ is a fresh message identifier. The second rule describes the case when a replica $r$ receive a message of object $x$. Note that each configuration contains all the message it ever generated.

$\llbracket \mathit{Obj} \rrbracket$ may be not precise enough, since it does not make any assumption about message delivery: Messages can be delivered in any order, a message can be delivery to a replica multiple times, and a message can be never delivered to a replica. This fits the assumption of state-based CRDT. However, the operation-based CRDT indeed have assumption about message delivery: each message is delivered to a replica at most once. Many operation-based CRDT has an additional assumption called causal-delivery: if operation $o_1$ happens before operation $o_2$, then it can not be the case that some replica receives the message of $o_2$ while it does not receive the message of $o_1$ yet. In latter section we will discuss how to combine objects with different requirements of message delivery.

In the next section, we will prove the correctness of individual objects. Let us propose the semantics for individual objects for different kinds of CRDT as follows.

The semantics of state-based object $x$ is given as follows: $\llbracket x \rrbracket_{s} = (\mathit{Config},\mathit{config}_0,\rightarrow)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathit{RState} = \mathbb{R} \rightarrow \Sigma$,

\item[-] $\mathit{TState} = \mathbb{MID} \times \mathbb{MSG} \times \mathbb{R} \times \mathbb{R} \times \{ \mathit{true},\mathit{false} \}$. Here $\mathit{true}$ represents that the message is generated and is not delivered yet, while $\mathit{false}$ represents that this message has already been delivered at least once.

%\item[-] $\mathit{MsgHB} = (\mathbb{MID} \times \mathbb{MID}) \cup (\mathbb{MID} \times \mathbb{R})$. $(m_1,m_2) \in \mathit{MsgHB}$ represents that the operation of message $o_1$ happens before the operation of message $o_2$; $(m_1,r') \in \mathit{MsgHB}$ means that $m_1$ is delivered to replica $r'$ but after that replica $r'$ does not launch any operation.

\item[-] $\mathit{Config} = \mathit{RState} \times \mathit{TState}$.

\item[-]

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
     R(r) = \sigma, \mathit{do}(\sigma,m,a,r) = (\sigma',b,\mathit{msg}), \mathit{unique}(\mathit{msgId})
   \end{array}}
     {(R,T) {\xrightarrow{\mathit{do}(m,a,b,r)}} (R[r:\sigma'],T \cup \{ (\mathit{msgId},\mathit{msg},r,r',\mathit{true}) \vert r' \in \mathbb{R} \setminus \{ r \} \})}
\end{array}$

\item[-]

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
      R(r) = \sigma, \mathit{receive}(\sigma,\mathit{msg}) = \sigma', \exists \mathit{msgId},(\mathit{msgId},\mathit{msg},r',r,\mathit{true}) \in T
   \end{array}}
     {(R,T) {\xrightarrow{\mathit{receive}(\mathit{msg},r)}} (R[r:\sigma'],T[(\mathit{msgId},\mathit{msg},r',r):\mathit{false}])}
\end{array}$
\end{itemize}



The semantics of operation-based object $x$ is given as follows: $\llbracket x \rrbracket_{\mathit{op}} = (\mathit{Config},\mathit{config}_0,\rightarrow)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathit{RState} = \mathbb{R} \rightarrow \Sigma$,

\item[-] $\mathit{TState} = \mathbb{MID} \times \mathbb{MSG} \times \mathbb{R} \times \mathbb{R}$.

\item[-] $\mathit{Config} = \mathit{RState} \times \mathit{TState}$.

\item[-]

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
     R(r) = \sigma, \mathit{do}(\sigma,m,a,r) = (\sigma',b,\mathit{msg}), \mathit{unique}(\mathit{msgId})
   \end{array}}
     {(R,T) {\xrightarrow{\mathit{do}(m,a,b,r)}} (R[r:\sigma'],T \cup \{ (\mathit{msgId},\mathit{msg},r,r') \vert r' \in \mathbb{R} \setminus \{ r \} \})}
\end{array}$

\item[-] When a message is delivered, we directly remove it from $T$. This makes a message be delivered at most once.

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
      R(r) = \sigma, \mathit{receive}(\sigma,\mathit{msg}) = \sigma', \exists \mathit{msgId},(\mathit{msgId},\mathit{msg},r',r) \in T
   \end{array}}
     {(R,T,\mathit{MsgHB}) {\xrightarrow{\mathit{receive}(\mathit{msg},r)}} (R,T \setminus \{ (\mathit{msgId},\mathit{msg},r',r) \} )}
\end{array}$
\end{itemize}

To deal with operation-based object with causal-delivery, we record the happen-before relation $\mathit{MsgHB}$ and the message deliver relation $\mathit{MsgDel}$ in each configuration. $(m_1,m_2) \in \mathit{MsgHB}$ represents that $m_1$ happens before $m_2$; $(m_1,r') \in \mathit{MsgDel}$ means that $m_1$ is already delivered to replica $r'$, but after that replica $r'$ does not launch any operation. With $\mathit{MsgHB}$, only minimal messages w.r.t $\mathit{MsgHB}$ can be delivered. The semantics $\llbracket x \rrbracket_{\mathit{cd}}$ of operation-based object $x$ with causal-delivery is given as $\llbracket x \rrbracket_{\mathit{cd}} = (\mathit{Config},\mathit{config}_0,\rightarrow)$, where

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $\mathit{RState} = \mathbb{R} \rightarrow \Sigma$,

\item[-] $\mathit{TState} = \mathbb{MID} \times \mathbb{MSG} \times \mathbb{R} \times \mathbb{R}$.

\item[-] $\mathit{MsgHB} \subseteq \mathbb{MID} \times \mathbb{MID}$.

\item[-] $\mathit{MsgDel}\subseteq \mathbb{MID} \times \mathbb{R}$.

\item[-] $\mathit{MsgHB}$ is acyclic. If $(i,r) \in \mathit{MsgDel}$, then there does not exists message $j$ that are launched by replica $r$ and $(i,j) \in \mathit{MsgHB}$.

\item[-] $\mathit{Config} = \mathit{RState} \times \mathit{TState} \times \mathit{MsgHB} \times \mathit{MsgDel}$.

\item[-]

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
     R(r) = \sigma, \mathit{do}(\sigma,m,a,r) = (\sigma',b,\mathit{msg}), \mathit{unique}(\mathit{msgId}), \\
     \mathit{msgHB}' = \mathit{upd}(\mathit{msgHB},\mathit{msgID},r) ,\mathit{msgDel}' = \mathit{upd}(\mathit{msgDel},\mathit{msgID},r)
   \end{array}}
     {(R,T,\mathit{msgHB},\mathit{msgDel}) {\xrightarrow{\mathit{do}(m,a,b,r)}} (R[r:\sigma'],T \cup \{ (\mathit{msgId},\mathit{msg},r,r') \vert r' \in \mathbb{R} \setminus \{ r \} \}, \mathit{msgHB}',\mathit{msgDel}')}
\end{array}$

\item[-]

$\begin{array}{l c}
   \bigfrac{
   \begin{array}{c}
      R(r) = \sigma, \mathit{receive}(\sigma,\mathit{msg}) = \sigma', \exists \mathit{msgId},(\mathit{msgId},\mathit{msg},r',r) \in T, \\
      \mathit{msgDel}' = \mathit{msgDel} \cup \{ (\mathit{msgId},r) \}.
   \end{array}}
     {(R,T,\mathit{msgHB},\mathit{msgDel}) {\xrightarrow{\mathit{receive}(\mathit{msg},r)}} (R,T \setminus \{ (\mathit{msgId},\mathit{msg},r',r),\mathit{msgHB},\mathit{msgDel}' \} )}
\end{array}$
\end{itemize}

Let $\mathit{upd}(\mathit{msgHB},\mathit{msgID},r)$ be the transitive closure of $\mathit{msgHB} \cup \{ (i,\mathit{msgID}) \vert i$ is launched in replica $r \vee (i,r) \in \mathit{msgDel}  \}$. Let $\mathit{upd}(\mathit{msgDel},\mathit{msgID},r) = \mathit{msgDel} \setminus \{ (i,r) \in \mathit{msgDel} \}$.



A action label is in the form of $\mathit{do}(x,m,a,b,r)$ or $\mathit{receive}(x,\mathit{msg},r)$, where $x \in \mathbb{OBJ}$, $m \in \mathbb{M}$, $a,b \in \mathbb{D}$, $r \in \mathbb{R}$, $\mathit{msg} \in \mathbb{MSG}$. Let $\mathbb{AID}$ be the set of action identifier. An action $a$ is a tuple $(l,i)$ with action label $l$ and action identifier $i$. Let $\mathit{ACT}$ be the set of actions.

An execution of $\llbracket \mathit{Obj} \rrbracket$ is a tuple $e = (E,\mathit{eo},\mathit{ro},\mathit{del})$. Here $E \subseteq \mathbb{ACT}$ is a set of actions, $\mathit{eo} \subseteq E \times E$ is a well-founded, transitive, irreflexive and total order on $E$, $\mathit{ro} \subseteq \mathit{eo}$ is a union of transitive, irreflexive and total orders of actions of same replica, $\mathit{del} \subseteq E \times E$ is the delivery relation. Given a execution, it is obvious to construct its history.

Given a sequence of transitions $\mathit{config}_0  {\xrightarrow{\alpha_1}} \mathit{config}_1 \ldots$ of $\llbracket \mathit{Obj} \rrbracket$, its execution $(E,\mathit{eo}$, $\mathit{ro},\mathit{del})$ is generated as follows: $E$ is the set $\{ \alpha_1,\ldots \}$; $\mathit{eo}$ is the total order of $\alpha_1,\ldots$; $\mathit{ro}$ is the projection of $\mathit{eo}$ over each replica; $(a_1,a_2) \in \mathit{del}$, if $a_2$ is a receive action and its receives the message generated by $e_1$.
}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "draft"
%%% End:
