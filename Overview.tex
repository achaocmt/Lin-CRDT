%!TEX root = draft.tex
\section{Overview}
\label{sec:overview}

\begin{figure}[t]
  % \centering
\begin{lstlisting}[caption={Pseudo-code of the Replicated Growable
Array (RGA) CRDT (adapted from~\cite{ShapiroPBZ11})},
captionpos=b,label={lst:rga}]
  payload Ti-Tree N, Set Tomb
  initial N = @|$\emptyset$|@, Tomb = @|$\emptyset$|@
  //@ initial lin = @|$\epsilon$|@

  addAfter(a,b) :
    atSource :
      precondition : a = @|$\circ$|@ or (a != @|$\circ$|@ and (a,_,_) @|$\in$|@ N and a @|$\not\in$|@ Tomb)
      let ts@|$_{\mathtt{b}}$|@ = getTimestamp()
      //@ let lin = insert(lin, @|$\alabelshort[{\tt addAfter}]{a,b}$|@, ts@|$_{\mathtt{b}}$|@)
    downStream(a, ts@|$_{\mathtt{b}}$|@, b) :
      N = N @|$\cup$|@ {(a, ts@|$_{\mathtt{b}}$|@, b)}
      //@ N@|$'$|@ = N @|$\cup$|@ {(a, ts@|$_{\mathtt{b}}$|@, b)}

  remove(a) :
    atSource :
      precondition : (a,_,_) @|$\in$|@ N and a @|$\notin$|@ Tomb
      //@ let lin = insert(lin, @|$\alabelshort[{\tt remove}]{a}$|@, @|$\mathsf{max}\, \{\ats(\alabel):\alabel\in \alabelset \}\,$|@)
    downStream(a) :
      Tomb = Tomb @|$\cup$|@ {a}
      //@ Tomb@|$'$|@ = Tomb @|$\cup$|@ {a}

  read() :
    let ret-list = traverse(N, Tomb)
    //@ let lin = insert(lin, @|$\alabellongind[{\tt read}]{}{{\tt ret\text{-}list}}{}$|@, @|$\mathsf{max}\, \{\ats(\alabel):\alabel\in \alabelset \}\,$|@)
    return ret-list
\end{lstlisting}
\end{figure}
%       precondition: a = @|$\circ$|@ or (a != @|$\circ$|@ and (a, ts@|$_{\mathtt{a}}$|@,_) @|$\in$|@ N)
%       precondition : (a,_,_) @|$\in$|@ N
\gpnote*{TODO}{
  Section sketch:
  \begin{itemize}
  \item Informal explanation of the system model. Multiple replicas,
    clients connect to any replica. Operations are propagated lazily.
  \item Explanation of the program model. We explain the code of RGA
    (\lstinline|atSource|, \lstinline|downStream|). Conflict
    resolution. Commutativity.
  \item We give a first intuition about the \CRDTLin{} of RGA. We
    might explain why standard Linearizability is not good enough.
  \item We present OR-Set. We explain that the linearization of OR-Set
    is more complicated without getting too tangled into de details.
    OR-Set is important because we need to explain that some
    operations will see a sub-sequence of the global linearization
    (in contrast to RGA above).
  \item If needed we can talk about the compositionality problem.
  \end{itemize}
}

\paragraph{System Model.}

We assume that the system is comprised of multiple nodes in a network.
In this work we will be concerned with the implementation of CRDTs,
and we will usually concentrate our discussion to the behaviors
allowed for \emph{an instance} of the data type.
We will generically call such an instance an \emph{object}.
As mentioned in~\autoref{sec:introduction} we assume that objects are
replicated among the participating nodes of the system -- which we
shall call replicas.

The execution model for an object is as follows:
\begin{itemize}
\item clients, which are programs issuing calls to the object, connect
  to any one replica (node of the system holding a copy of the object)
  and performs the operation in that replica, we shall call such a
  replica the origin or \emph{source},
\item executing an operation is done in two phases. Assuming that the
  operation requires reading and updating the state of the object, the
  state of the object in the source replica is read first (we shall sometimes
  refer to this part of the operation as the generator
  following~\cite{ShapiroPBZ11}), and then, if the state needs to be changed as part of the operation -- e.g.
  an \lstinline|addRight| operation of RGA -- an update is
  generated which shall be executed in all the replicas holding copies
  of the object (we shall refer to the update as the effector).
  We assume throughout this paper that effectors are executed immediate
  in the source replica,
\item finally, as the system progresses, the effector of the operation
  will be delivered to each of the replicas holding a copy of the
  object.
\end{itemize}
This model is depicted in~\autoref{fig:system-model}.
\fxwarning[nomargin, inline]{We need the picture}.

\paragraph{CRDT implementations}

Following the description above~\cite{ShapiroPBZ11} presents the code
for a number of CRDT implementations.
%
Here we consider the code of the RGA algorithm presented
in~\autoref{lst:rga}.
%
Let us first consider the structure of the data type implementation:
\begin{itemize}
\item the keyword \lstinline|payload| introduces the state that is
  used to represent the object. This is akin to the fields of a class
  file in an object oriented language such as Java. In the specific
  case of RGA we hate a variable \lstinline|N| of type
  \lstinline|Ti-Tree| (to be discussed later), and a variable
  \lstinline|Tomb| of type \lstinline|Set|.
\item After that we find the definitions of the three operations we
  discussed in the introduction: \lstinline|addAfter|,
  \lstinline|remove| and \lstinline|read|.
\item The effectful operations \lstinline|addAfter| and
  \lstinline|remove| have two labels marked in red:
  \lstinline|atSource| and \lstinline|downStream|.
  These represent the code to be executed as the generator and
  effector respectively. Hence, the code under the label
  \lstinline|atSource| is executed only at the source replica and it
  generates the arguments that the code under \lstinline|downStream|
  will execute in each of the replicas.
\item We can also notice that under the labels there are
  \lstinline|precondition| annotations indicating facts that are
  assumed about the state of the object upon execution of either of
  the generator or effector of the operation.
\end{itemize}
Reconsidering~\autoref{fig:system-model} we can then say that the
source of the arrows in each replica represent the execution of an
\lstinline|atSource| jointly with the \lstinline|downStream| of the
operation at the source replica.
%
The sink of the arrows represents the delivery and execution of the
generator of the operation in a replica other than the source.


In the rest of this section we consider two examples of CRDT
implementations \gpwarning*{TODO} { and their linearization arguments.
}

\paragraph{RGA CRDT implementation}
% \gpwarning[nomargin, inline]{
% We explain the \lstinline|Ti-Tree| and the tombstone of RGA. We give
% an example of conflict resolution: - two \lstinline|addAfter(a, _)|
% operations, and perhaps a - \lstinline|remove(_)| and
% \lstinline|addAfter(_, _)| operation. We explain the preconditions,
% their relation to causality, etc.
% }

As it is common to many CRDT implementations, in RGA replicas will use
a timestamp mechanism to keep track of the causality between updates
to the list, effectively capturing when two updates are concurrent,
and moreover, they will keep the information relating the causal order
in which elements are added to the list.
%
Provided with this causality information, the timestamps will be used
to resolve conflicts in a deterministic way.
%
More concretely, each replica will keep what we shall name a
\emph{Timestamp Tree} (\lstinline|Ti-Tree|) containing in every tree
node a pair with the element added to the list (for instance the
character \lstinline|b|), and a timestamp associated to it
(\lstinline|t|$_{\mathtt{b}}$) which will be used to resolve
conflicts.
%
We will encode the tree as a set containing triples (representing
nodes) of the form (\lstinline|a|, \lstinline|ts|$_{b}$, \lstinline|b|)
representing the fact that there is an element \lstinline|b| in the
tree with timestamp \lstinline|ts|$_{\mathtt{b}}$ and whose parent is the item
\lstinline|a| also present in the tree.
%
The tree-ness property will be ensured by construction.


If we look at the \lstinline|atSource| portion of the
\lstinline|addAfter(a,b)| method we can see that precondition requires
the \lstinline|a| to exist in the tree before the insertion of
\lstinline|b| after it.
%
We remark at this point that the data structure is initialized with a
preexisting initial element $\circ$.
%
The generator then samples a timestamp \lstinline|t|$_{\mathtt{b}}$
for \lstinline|b| which is assumed to be larger than any
timestamp presently occurring in the \lstinline|Ti-Tree|
\lstinline|N|.
\gpnote{Add note about uniqueness of TSs (rid).}
%
Looking at the \lstinline|downStream| portion of
\lstinline|addAfter(a,b)| we see that the effect of the operation is
to add the triple \lstinline|(a, ts|$_{\mathtt{b}}$\lstinline|, b)|
representing the fact that the element \lstinline|b| is a child of the
item \lstinline|a| in the tree.
%
Then, the tree structure is representative of the causality of the
tree.
%
Notice that a client of the object will only ever attempt to add an
element after another element which has already seen (mandated by the
\lstinline|addAfter| operation of the API).
%
Hence, the parent node of any node is causally related before it.
%
Similarly, nodes that are not related to each other on any path of
the tree (eg. siblings) are not causally related.
%
An example of such a tree is shown in~\ref{fig:rga-tree}.
\gpwarning*{Example}{Ask Chao for a concrete example.}
%

Considering a \lstinline|Ti-tree| constructed in this way, we can
obtain a list by traversing the tree in pre-order fashion, with the
proviso that siblings are ordered according to their timestamps. 
%
\autoref{fig:rga-tree} shows the tree that results from the given
tree. 

We have so far ignored the \lstinline|remove| operation.
%
Consider the case where a client issues an \lstinline|addAfter(a, b)|
on a replica whereas another client issues a \lstinline|remove(a)|
operation in another replica. 
%
If the effector of \lstinline|remove(a)| reaches every replica after
the effector of \lstinline|addAfter(a, b)| there is no problem since
the semantics is obvious (the element \lstinline|a| is removed after
the element \lstinline|b| has been added). 
%
However, if the operations reach some replica in the opposite order
(recall that these are concurrent operations) we have a problem, since
the precondition of the effector of \lstinline|addAfter(a, b)|
requires that the element \lstinline|a| be present in the
\lstinline|Ti-tree| of the replica.

To avoid this kind of conflict, thus rendering these operations
commutative (c.f. CRDT), RGA does not really erase elements from the
\lstinline|Ti-tree|.
%
Instead, an additional data structure called a tombstone is used to
keep track of elements that have been conceptually erased and should
not be considered when reading the data structure with the
\lstinline|read| operation. 
%
In our case the tombstone is simply a set \lstinline|Tomb| of
elements. 
%
With this explanation the code of the \lstinline|remove| operation
in~\autoref{lst:rga} should be self-explanatory. 

Finally, the implementation of \lstinline|read| performs the pre-order
traversal as explained before, where all the elements in the tombstone
\lstinline|Tomb| are ignored from the output list. 


% In RGA algorithm, a replica store the list as a timestamp insertion
% tree (TI-tree) $N$, and stores the deleted items in tombstone
% $\mathit{Tomb}$. A TI-tree $N$ is a set of tuples $(a,t,p)$, where
% $a$ is a item, $t$ is its unique time-stamp, and $p$ is the
% time-stamp of its ``parent'' node. Each time-stamp is a tuple
% $(c,r)$ with $c \in \mathbb{N}$ and $r \in \mathbb{R}$. A total
% order $<_{\mathit{ts}}$ between time-stamps is defined, such that
% $(c_1,r_1) <_{\mathit{ts}} (c_2,r_2)$, if $c_1 < c_2 \vee (c_1 = c_2
% \wedge r_1 <_r r_2)$, where $<_r$ is a total-order over
% $\mathbb{R}$. There is a pre-existed item $\circ$ of TI-tree with
% time stamp $(0,r_0)$, which are considered as the root of the tree.
% Each element of $N$ should have unique item and time stamp, and the
% elements of $N$ are required to form a tree by following the parent
% field. The tombstone $\mathit{Tomb}$ is a set of items and records
% items been removed from the list. 

% \ce{Make the distinction between an operation being
% \emph{originated} at some replica, and whose downstream is
% \emph{executed} at some replica}

\gpwarning[nomargin, inline]{I think it would be useful to show a
  graphical example of linearizations here. Something like the
  examples in the HW paper would do.}

\paragraph{OR-Set CRDT Implementation} 

The Observed-Remove Set (OR-Set) is another CRDT~\cite{ShapiroPBZ11}
which implements a set interface with methods: \lstinline|add(a)|,
\lstinline|remove(a)| and \lstinline|read()|.\footnote{Alternatively
  we could provide an interface with the method \lstinline|lookup(a)|
  returning a boolean with the same consequences as the
  \lstinline|read()| method we provide.} 
%
The meaning of these methods is self-evident from their names.
%
However, what is not evident is what are the results of conflicting
concurrent operations. 
%
Consider for example the case where two replicas add a certain element
\lstinline|a| and then one of them removes that element.
%
If we consider an interleaving based execution of these operations
there are two options depending on the interleaving:
\begin{inparaenum}[i)]
\item if the \lstinline|remove(a)| operation is the last operation
  then the expected set is empty, since the two consecutive
  \lstinline|add(a)| operations are idempotent, and the
  \lstinline|remove| would remove the only occurrence of
  \lstinline|a|, 
\item on the other hand, if the operation \lstinline|add(a)| of the
  non-removing process comes last, the final set could contain the
  element \lstinline|a|.
\end{inparaenum}
As we have explained before, in our system model the operations can
arrive in one order to one replica and in a different order to another
replica.
%
To guarantee convergence, OR-Set must ensure that regardless of the
ordering, the resulting set will be the same. 
%
To that end, OR-Set \lstinline|add| operations will tag each added
element with a unique identifier. 
%
Then,a remove operation will only remove the elements which has
already seen.
%
For instance, in the example above, the remove of \lstinline|a| will
only remove the element that has been previously added by in the same
replica, since this item as been observed by the \lstinline|remove|
operating -- and thus its identifier is known to it --. However, the
concurrent \lstinline|add(a)| operation will have an identifier that
has not been observed by the \lstinline|remove| (since they are
concurrent). 
%
Therefore the item will not be removed, even in the case where the two
adds are performed in a replica before the remove. 

The code of OR-Set is shown in~\autoref{lst:or-set} where for the time
being we ignore the lines marked with a comment (\lstinline|\\@|).

\gpwarning[nomargin, inline]{Add the argument for linearization of
  OR-Set. This might be a little tricky to explain.}

% Method $\mathit{add}(a,b)$ intends to add item $a$ into the list at a
% position immediately after that of a existing item $b$. Method
% $\mathit{rem}(a)$ removes $a$ from the list. Method $\mathit{read}$
% returns the current list content. When the current replica does
% $\mathit{add}(a,b)$, it generate a tuple $(a,ts_a,ts_b)$ and put it
% into $N$. Here $ts_b$ is the time-stamp of $b$, and $ts_a$ is a new
% time-stamp that is larger than any time stamp in $N$. When the current
% replica does $\mathit{rem}(a)$, it put $a$ into tombstone. When the
% current replica does $\mathit{read}$, it uses function
% $\mathit{trans}(N,\mathit{Tomb})$ to return the list seen by the
% current replica, which is a sequences obtained by traversing $N$ in
% prefix order (children are visited in decreasing time-stamp order) and
% keeping only items that are not in $\mathit{Tomb}$. 

\begin{figure}[!t]
  \centering
\begin{lstlisting}[caption={Pseudo-code of the OR-Set CRDT},
captionpos=b,label={lst:or-set}] 
  payload Set S 
  initial S = @|$\emptyset$|@ 
  //@ initial lin = @|$\epsilon$|@

  add(a) :
    atSource :
      let k = getUniqueIdentifier()
      //@ let lin = lin@|$\,\cdot\,\alabelshort[{\tt add}]{a,k}$|@
    downStream(a, k) :
      S = S @|$\cup$|@ {(a, k)}
      //@ S@|$'$|@ = S @|$\cup$|@ {(a, k)}

  remove(a) :
    atSource :
      let R = @|$\{$|@ (a,k): (a,k) @|$\in$|@ S @|$\}$|@
      //@ let lin = lin@|$\,\cdot\,\alabellongind[{\tt readIds}]{a}{R}{}\,\cdot\,\alabelshort[{\tt remove}]{a,R}$|@
    downStream(R) :
      S = S @|$\setminus$|@ R
      //@ R = @|$\{ (a,k): \exists\ \alabel = \alabellongind[{\tt add}]{a,k}{\bot}{*}.\ (\alabel, \alabelshort[{\tt remove}]{a,R}) \in \avisord$|@
                       @|$\land\,\forall\ \alabel' = \alabellongind[{\tt remove}]{a,*}{\bot}{*}.\ \{(\alabel,\alabel'),(\alabel',\alabelshort[{\tt remove}]{a,R})\}\not\subseteq \avisord\}$|@
      //@ S@|$'$|@ = S @|$\setminus$|@ R

  read() :
    let A = {a : @|$\exists$|@ k. (a,k) @|$\in$|@ S}
    //@ let lin@|$'$|@ = lin@|$\,\cdot\,\alabellongind[{\tt read}]{}{A}{}$|@
    return A
\end{lstlisting}
\end{figure}
%      precondition : %@|$\exists$|@ k. (a,k) @|$\in$|@ S
%let @|$\alabel = \alabellongind[remove]{a,R}{\bot}{i}$|@
%      //@ @|$\alpha(S) \xrightarrow{\alabelshort[add]{a,k}} \alpha(S')$|@
%       //@ @|$\alpha(S) \xrightarrow{\alabellongind[readIds]{a}{R}{}} \alpha(S)$|@
%       //@ @|$\alpha(S) \xrightarrow{\alabelshort[remove]{a,R}} \alpha(S')$|@
%     //@ @|$\alpha(S) \xrightarrow{\alabellongind[read]{}{A}{}} \alpha(S)$|@

% In the downstream of a $\alabellongNoret[\mathit{add}]{\argv}$
% operation, an tuple $(\argv,\ats)$ will be added to the local state;
% while in the downstream of a $\alabellongNoret[\mathit{add}]{\argv}$
% operation, a set $S_1$ will be removed from the local state. We call
% such tuple $(\argv,\ats)$ or set $S_1$ the content of the downstream.
% The following is the condition $C_2$ for or-set implementatio.

%%% Local Variables:
%%% mode: latex
%%% TeX-master: "draft"
%%% End:
