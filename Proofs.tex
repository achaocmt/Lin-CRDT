%!TEX root = draft.tex
\section{Proving \CRDTLin{}}

\textblue{
I think this section should be about proving linearizability. Here we introduce:
\begin{itemize}
\item a semantics for CRDTs
\item a general methodology based on simulation relation (explain that it can also be seen as invariant checking)
\item the two proof strategies for building linearizations, as particular instances of that simulation relation
\end{itemize}}

TODO INTRODUCE THIS SECTION

\subsection{Proof Methodology}

Our approach for proving replication-aware linearizability (w.r.t. $\Spec{}$) consists in instrumenting the object semantics with an auxiliary variable $\aseqord$ recording a linearization of the current history (recorded in the object's global configurations). 
The linearization $\aseqord$ is updated every time an operation executes the {\tt atSource} procedure~\footnote{For readers familiars with proving classical linearizability for concurrent objects, this is akin to assuming that {\tt atSource} is a ``fixed'' linearization point. However, differently from the classical case, the operation may not be necessarily placed at the end of the current linearization.} by adding the current operation at some specific position. When the object contains query-update operations, the operations are first rewritten according to a rewriting $\gamma$ as in \autoref{definition:distributed linearizability} before being placed in the linearization. 
Then, the objective is to prove that $\aseqord$ being an \crdtlinearization{} of the current history (w.r.t. $\Spec{}$) is an invariant of the object. This invariant may be strengthened with additional requirements in order to become inductive. In the case of the objects we investigated, the inductive invariant is defined as the conjunction of two properties:
\begin{itemize}
%\setlength{\itemsep}{0.5pt}
\item[-] $\mathsf{\CRDTLinshort{}}$: the sequence $\aseqord$ is an \crdtlinearization{} of the current history (w.r.t. $\Spec{}$) 
%is \crdtlinearizable{} w.r.t \Spec{} and $\mathit{lin}$ is a linearization. Here $\alabelset$ is the set of labels in domain of $\downstreams$.

\item[-] $\mathsf{ReplicaStates}$: For each replica $\arep$ with local configuration $(\alabelset,\astate)$, the state $\sigma$ is obtained by applying the downstreams of the operations in $\alabelset$ (that have been delivered to $\arep$) in the order defined by $\aseqord$.  
\end{itemize}
We may also use additional assertions describing the effect of each downstream.

We have applied this methodology to a range of CRDT objects described in~\cite{}, and we have identified two instantiations which differ in the way in which the linearization $\aseqord$ is updated (when executing {\tt atSource}). For a first class of objects that includes the OR-Set in Listing~\ref{lst:or-set}, the linearization $\aseqord$ is defined by the order in which the {\tt atSource} procedures are executed, i.e., every new operation executing {\tt atSource} is added at the end of the current linearization (\S~\ref{subsec:time order of execution as linearization}). 
The second class of objects that includes the RGA object in Listing~\ref{lst:rga}, supports \CRDTLinshort{} proofs in which the linearization is built based on timestamps, e.g., $\aseqord$ is consistent with the order between the timestamps generated by operations (\S~\ref{subsec:time-stamp order as linearizabtion}).


%
%For some CRDT implementations, when proving its correctness, we can use the total-order of executions as linearization. For such CRDT implementations, our proof approach is as follows:
%
%
%Given a object $\aobj$ and a specification \Spec{}, we construct a predicate $P(\mathit{config},\mathit{lin})$ where $\mathit{config} = (\gstates, \avisord, \downstreams)$ is a configuration of $\llbracket \aobj \rrbracket_{\mathit{op}}$, and $\mathit{lin}$ is a sequence used as linearization. We require $P(\mathit{config},\mathit{lin})$ to be a conjunction of the following statements:
%
%\begin{itemize}
%\setlength{\itemsep}{0.5pt}
%\item[-] Condition $C_1$ (linearizability): The history $(\alabelset, \avisord)$ is \crdtlinearizable{} w.r.t \Spec{} and $\mathit{lin}$ is a linearization. Here $\alabelset$ is the set of labels in domain of $\downstreams$.
%
%\item[-] Condition $C_2$ (downstream): A statement about downstream for each operation label in $\mathit{config}$.
%
%\item[-] Condition $C_3$ (sequential explanation): For each replica $\arep$, we have that $\gstates(\arep).\astate = \mathit{apply}(\mathit{lin},\gstates(\arep).\alabelset)$.
%\end{itemize}
%
%Here the function $\mathit{apply}(\mathit{lin},S)$ returns a local state obtained by applying downstream of operations in $S$ according to total order of $\mathit{lin}$.

\subsection{Execution-Order Linearizations}
\label{subsec:time order of execution as linearization}

%Then, we need to prove that $P$ is a simulation relation. Moreover, we prove that we can always obtain a new linearization by putting a new operation after the tail of a old linearization. We call such relation a execution-order simulation relation.
%
%\begin{itemize}
%\setlength{\itemsep}{0.5pt}
%\item[-] $P(\mathit{config}_0,\epsilon)$ holds, where $\mathit{config}_0$ is the initial configuration.
%
%\item[-] If $P(\mathit{config},\mathit{lin})$ holds and $\mathit{config} {\xrightarrow{\alabel}} \mathit{config}'$, then $P(\mathit{config}', \mathit{lin} \cdot \alabel)$ holds.
%
%\item[-] If $P(\mathit{config},\mathit{lin})$ holds and $\mathit{config} {\xrightarrow{}} \mathit{config}'$, then $P(\mathit{config}',\mathit{lin})$ holds.
%\end{itemize}
%
%It is easy to see that, execution-order simulation relation implies a \crdtlinearizable{} relation proof with the execution as linearization.

In this section, we describe a first instantiation of the methodology described above using as example the OR-Set object in Listing~\ref{lst:or-set}. The proof that this object satisfies \crdtlin{} w.r.t. the specification defined in Example~\ref{} relies on several annotations which are given on the lines starting with {\tt //@} in Listing~\ref{lst:or-set}.

 the linearization order is exactly the order in which the operations execute the {\tt atSource} procedure. 

We can see that, in the definition of $P(\mathit{config},\mathit{lin})$, condition $C_2$ is specific to CRDT implementations. The pseudo-code of or-set implementation is shown in \autoref{lst:or-set}. Its formal definition can be easily obtained from the pseudo-code and is omitted here.

\begin{example}[Condition $C_2$ for or-set implementation]
\label{example:condition c2 for or-set implementation}
Given a configuration $(\gstates, \avisord, \downstreams)$ and an operation $\alabel \in \dom{\avisord}$, the downstream of $\alabel$ is given as follows: 

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $\alabel = \alabellongNoret[\mathit{add}]{\argv}$: Assume $\alabel$ is generated for replica $\arep$. Then, the downstream of $\alabel$ is a function that maps a state $(S,\mathit{maxTS})$ into $(S \cup \{ (a,(c+1,r)) \}, \mathit{max}(\mathit{maxTS},(c+1,r)))$.  
    
    Here $c = \mathsf{max}\{ c' \vert \exists \alabel'$, such that $\alabel' = \alabellongNoret[\mathit{add}]{\_}, (\alabel', \alabel) \in \avisord$, and $(\_,(c',\_))$ is the downstream content of $\alabel' \}$. 

\item[-] If $\alabel = \alabellongNoret[\mathit{remove}]{\argv}$: The downstream of $\alabel$ is a function that maps a state $(S,\mathit{maxTS})$ into $(S \setminus S', \mathit{maxTS})$. 
    Here $S' = \{ \alabel' = \alabellongNoret[\mathit{add}]{\argv} \vert (\alabel',\alabel) \in \avisord, \neg \exists \alabel'' = \alabellongNoret[\mathit{remove}]{\argv}$, such that $(\alabel',\alabel''), (\alabel'',\alabel) \in \avisord \}$. 

\item[-] If $\alabel = \alabellongNoret[\mathit{read}]{}$: The downstream of $\downstreams(\alabel)$ is the identical function. 
\end{itemize}
\end{example}

The proof for or-set can be found in Appendix \ref{subsec:appendix proofs of or-set implementation}. The counter implementation can be similarly proved and its proof can be found in Appendix \ref{a}.

\subsection{Timestamp-Order Linearizations}
\label{subsec:time-stamp order as linearizabtion} 

For some CRDT implementation, such as RGA, the timestamp plays a important roles in conflict resolution. In such situation, the total-order of execution may not be used as linearization. For example, consider $\alabellongNoret[\mathit{write}]{c}$ and $\alabellongNoret[\mathit{add}]{d}$ actions of \figurename~\ref{fig:a failed example of composing a multi-value register with a last-write-win register} for LWW-register. Although $\alabellongNoret[\mathit{add}]{d}$ happens earlier in execution, since the timestamp of $\alabellongNoret[\mathit{write}]{c}$ is smaller than that of $\alabellongNoret[\mathit{write}]{d}$, we should put $\alabellongNoret[\mathit{write}]{c}$ before $\alabellongNoret[\mathit{write}]{d}$ in linearization.

Some method, such as $\mathit{write}$ of RGA, generates new timestamp; while other methods do not generate new timestamp. Based on this observation, we slightly change the operational semantics as follows: For the method that generate new timestamps, 


\[
  \inferrule[\text{\sc Operation-ts}]
  {\gstates(r) = (\alabelset, \astate) \\ \mathit{do}(\sigma,\amethod,\argv,\arep) = (\retv,\effector,\ats) \\  \effector(\astate) = \astate' \\ \alabel = \alabellongind{\argv}{\retv}{\ats} \\ \mathit{unique}(\ats) }
  {(\gstates, \avisord, \downstreams) \xrightarrow{\alabel} (\gstates[\arep \leftarrow (\alabelset \cup \{\alabel\}, \astate')],
    \avisord \cup (\alabelset \times \{\alabel\}), \downstreams[\alabel \rightarrow \effector])}
\]

Here we use $\mathit{do}(\sigma,\amethod,\argv,\arep) = (\retv,\effector,\ats)$ to emphasize that $\ats$ is the new-generated timestamp, and by $\alabel = \alabellongind{\argv}{\retv}{\ats}$ we record this timestamp in operation label. 

We require $P(\mathit{config},\mathit{lin})$ to be a conjunction of conditions $C_1$, $C_2$, $C_3$ and $C_4$, where condition $C_4$ is defined as follows: 

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] Condition $C_4$ (timestamp): Given operations $\alabel$ and $\alabel'$ of methods that generate new timestamp. $(\alabel,\alabel') \in \avisord$ implies that the timestamp of $\alabel$ is less than that of $\alabel'$. 
\end{itemize} 

For simplicity, we define the notion of ``timestamp of operations'' as follows: 

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $\alabel$ is an operation of methods that generate a new time-stamp $\ats$, then the timestamp of $\alabel$ is $\ats$. 

\item[-] If $\alabel$ is an operation of methods that do not generate new time-stamp: If $\alabel$ do not see any operation that generate new timestamp, then the timestamp of $\alabel$ is a default minimal timestamp; Else, the timestamp of $\alabel$ is $\mathsf{max} \{ \ats' \vert \exists \alabel'$, such that $(\alabel',\alabel) \in \avisord, \alabel$ generates a new time-stamp $\ats' \}$. 
\end{itemize} 

Then, we need to prove that $P$ is a simulation relation. Moreover, we prove that we can always obtain a new linearization by putting a new operation $\alabel$ after the last operation with a timestamp less or equal than $\alabel$. We call such relation a timestamp-order simulation relation. 

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] $P(\mathit{config}_0,\epsilon)$ holds, where $\mathit{config}_0$ is the initial configuration.

\item[-] If $P(\mathit{config},\mathit{lin})$ holds and $\mathit{config} {\xrightarrow{\alabel}} \mathit{config}'$, then $P(\mathit{config}', \mathit{lin} \oplus \alabel)$ holds. Here  $\mathit{lin} \oplus \alabel$ is obtained from $\mathit{lin}$ by inserting $\alabel$ after the last operations with timestamp less or equal than that of $\alabel$. 

\item[-] If $P(\mathit{config},\mathit{lin})$ holds and $\mathit{config} {\xrightarrow{}} \mathit{config}'$, then $P(\mathit{config}',\mathit{lin})$ holds.
\end{itemize}

It is easy to see that, timestamp-order simulation relation implies a \crdtlinearizable{} relation proof. Moreover, we can obtain a linearization in the following form: For each operation $\alabel$, the timestamp of $\alabel$ is larger or equal than that of operations before $\alabel$ in linearization, and is less or equal than that of operations after $\alabel$ in linearization. We call such linearization a timestamp linearization. We can see that timestamp-order simulation relation implies a timestamp linearization.

The following is the condition $C_2$ for RGA. 

\begin{example}[Condition $C_2$ for RGA]
\label{example:condition c2 for rga} 
Given a configuration $(\gstates, \avisord, \downstreams)$ and an operation $\alabel \in \dom{\avisord}$, the downstream of $\alabel$ is given as follows. 

\begin{itemize}
\setlength{\itemsep}{0.5pt}
\item[-] If $\alabel = \alabellongNoret[\mathit{add}]{a,b}$: Assume $\alabel$ is generated for replica $\arep$. Then, the downstream of $\alabel$ is a function that maps a state $(N,\mathit{Tomb})$ into $(N \cup \{ (a,\ats_b,\ats_a) \}, \mathit{Tomb})$. 
    
    If $a = \circ$, then $\ats_a = (0,r_0)$; Else, $\ats_a$ is the timestamp of $\alabellongNoret[\mathit{add}]{\_,a}$. If no $\mathit{add}$ operation is visible to $\alabel$, then $\ats_b = (1,\arep)$; Else, $\ats_b = (c+1,\arep)$, and $c = \mathsf{max}\{ c' \vert \exists \alabel' = \alabellongNoret[\mathit{add}]{\_,\_}$, such that $(\alabel', \alabel) \in \avisord$, and $(\_,(c',\_))$ is the timestamp of $\alabel' \}$. 


\item[-] If $\alabel = \alabellongNoret[\mathit{remove}]{\argv}$: Then, the downstream of $\alabel$ is a function that maps a state $(N,\mathit{Tomb})$ into $(N, \mathit{Tomb} \cup \{ a \})$.

\item[-] If $\alabel = \alabellongNoret[\mathit{read}]{}$: Then, $\downstreams(\alabel)$ is the identical function. 
\end{itemize} 
\end{example}

The detailed of RGA can be found in Appendix \ref{subsec:appendix proofs of rga}. The LWW register can be similarly proved and its proof can be found in Appendix \ref{a}.




